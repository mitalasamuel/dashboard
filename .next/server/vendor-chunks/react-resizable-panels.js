"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   assert: () => (/* binding */ assert)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// eslint-disable-next-line no-restricted-imports\nconst { createElement, createContext, createRef, forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, useState } = react__WEBPACK_IMPORTED_MODULE_0__;\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nconst wrappedUseId = typeof useId === \"function\" ? useId : ()=>null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n    const idFromUseId = wrappedUseId();\n    const idRef = useRef(idFromParams || idFromUseId || null);\n    if (idRef.current === null) {\n        idRef.current = \"\" + counter++;\n    }\n    return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\nfunction PanelWithForwardedRef({ children, className: classNameFromProps = \"\", collapsedSize, collapsible, defaultSize, forwardedRef, id: idFromProps, maxSize, minSize, onCollapse, onExpand, onResize, order, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const context = useContext(PanelGroupContext);\n    if (context === null) {\n        throw Error(`Panel components must be rendered within a PanelGroup container`);\n    }\n    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, registerPanel, resizePanel, unregisterPanel } = context;\n    const panelId = useUniqueId(idFromProps);\n    const panelDataRef = useRef({\n        callbacks: {\n            onCollapse,\n            onExpand,\n            onResize\n        },\n        constraints: {\n            collapsedSize,\n            collapsible,\n            defaultSize,\n            maxSize,\n            minSize\n        },\n        id: panelId,\n        idIsFromProps: idFromProps !== undefined,\n        order\n    });\n    const devWarningsRef = useRef({\n        didLogMissingDefaultSizeWarning: false\n    });\n    // Normally we wouldn't log a warning during render,\n    // but effects don't run on the server, so we can't do it there\n    {\n        if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n            if (defaultSize == null) {\n                devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n                console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n            }\n        }\n    }\n    useImperativeHandle(forwardedRef, ()=>({\n            collapse: ()=>{\n                collapsePanel(panelDataRef.current);\n            },\n            expand: ()=>{\n                expandPanel(panelDataRef.current);\n            },\n            getId () {\n                return panelId;\n            },\n            getSize () {\n                return getPanelSize(panelDataRef.current);\n            },\n            isCollapsed () {\n                return isPanelCollapsed(panelDataRef.current);\n            },\n            isExpanded () {\n                return !isPanelCollapsed(panelDataRef.current);\n            },\n            resize: (size)=>{\n                resizePanel(panelDataRef.current, size);\n            }\n        }), [\n        collapsePanel,\n        expandPanel,\n        getPanelSize,\n        isPanelCollapsed,\n        panelId,\n        resizePanel\n    ]);\n    const style = getPanelStyle(panelDataRef.current);\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel\": \"\",\n        \"data-panel-id\": panelId,\n        \"data-panel-group-id\": groupId,\n        // e2e test attributes\n        \"data-panel-collapsible\": collapsible || undefined,\n        \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n    });\n}\nconst Panel = forwardRef((props, ref)=>createElement(PanelWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        console.error(message);\n        throw Error(message);\n    }\n}\nconst PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n    actual = parseFloat(actual.toFixed(fractionDigits));\n    expected = parseFloat(expected.toFixed(fractionDigits));\n    const delta = actual - expected;\n    if (delta === 0) {\n        return 0;\n    } else {\n        return delta > 0 ? 1 : -1;\n    }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({ panelConstraints: panelConstraintsArray, panelIndex, size }) {\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints != null);\n    let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;\n    if (fuzzyCompareNumbers(size, minSize) < 0) {\n        if (collapsible) {\n            // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n            const halfwayPoint = (collapsedSize + minSize) / 2;\n            if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n                size = collapsedSize;\n            } else {\n                size = minSize;\n            }\n        } else {\n            size = minSize;\n        }\n    }\n    size = Math.min(maxSize, size);\n    size = parseFloat(size.toFixed(PRECISION));\n    return size;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({ delta, layout: prevLayout, panelConstraints: panelConstraintsArray, pivotIndices, trigger }) {\n    if (fuzzyNumbersEqual(delta, 0)) {\n        return prevLayout;\n    }\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    assert(firstPivotIndex != null);\n    assert(secondPivotIndex != null);\n    let deltaApplied = 0;\n    //const DEBUG = [];\n    //DEBUG.push(`adjustLayoutByDelta() ${prevLayout.join(\", \")}`);\n    //DEBUG.push(`  delta: ${delta}`);\n    //DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n    //DEBUG.push(`  trigger: ${trigger}`);\n    //DEBUG.push(\"\");\n    // A resizing panel affects the panels before or after it.\n    //\n    // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed panel\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints);\n                //DEBUG.push(`edge case check 1: ${index}`);\n                //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n                if (panelConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const panelConstraints = panelConstraintsArray[index];\n                    assert(panelConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = panelConstraints;\n                    if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a panel at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints);\n                const { collapsible } = panelConstraints;\n                //DEBUG.push(`edge case check 2: ${index}`);\n                //DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const panelConstraints = panelConstraintsArray[index];\n                    assert(panelConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = panelConstraints;\n                    if (fuzzyNumbersEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n        }\n    //DEBUG.push(\"\");\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information tooâ€“\n        // as an expanding panel might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        //DEBUG.push(\"pre calc...\");\n        while(true){\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: 100\n            });\n            const delta = maxSafeSize - prevSize;\n            //DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= panelConstraintsArray.length) {\n                break;\n            }\n        }\n        //DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    //DEBUG.push(`  -> adjusted delta: ${delta}`);\n    //DEBUG.push(\"\");\n    }\n    {\n        // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while(index >= 0 && index < panelConstraintsArray.length){\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            } else {\n                index++;\n            }\n        }\n    }\n    //DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n    //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    //DEBUG.push(\"\");\n    // If we were unable to resize any of the panels panels, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n    if (fuzzyNumbersEqual(deltaApplied, 0)) {\n        //console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panels in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePanel({\n            panelConstraints: panelConstraintsArray,\n            panelIndex: pivotIndex,\n            size: unsafeSize\n        });\n        // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one panel caused another one to change collapsed state\n        if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while(index >= 0 && index < panelConstraintsArray.length){\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePanel({\n                    panelConstraints: panelConstraintsArray,\n                    panelIndex: index,\n                    size: unsafeSize\n                });\n                if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n                    break;\n                }\n                if (delta > 0) {\n                    index--;\n                } else {\n                    index++;\n                }\n            }\n        }\n    }\n    //DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n    //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    //DEBUG.push(\"\");\n    const totalSize = nextLayout.reduce((total, size)=>size + total, 0);\n    //DEBUG.push(`total size: ${totalSize}`);\n    //console.log(DEBUG.join(\"\\n\"));\n    if (!fuzzyNumbersEqual(totalSize, 100)) {\n        return prevLayout;\n    }\n    return nextLayout;\n}\nfunction getResizeHandleElementsForGroup(groupId) {\n    return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandleElementIndex(groupId, id) {\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handles.findIndex((handle)=>handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n    return index !== null && index !== void 0 ? index : null;\n}\nfunction determinePivotIndices(groupId, dragHandleId) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId);\n    return index != null ? [\n        index,\n        index + 1\n    ] : [\n        -1,\n        -1\n    ];\n}\nfunction getPanelGroupElement(id) {\n    const element = document.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandleElement(id) {\n    const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n    var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n    const handle = getResizeHandleElement(handleId);\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n    const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterPanelGroupBehavior({ committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout }) {\n    useRef({\n        didWarnAboutMissingResizeHandle: false\n    });\n    useEffect(()=>{\n        const eagerValues = eagerValuesRef.current;\n        assert(eagerValues);\n        const { panelDataArray } = eagerValues;\n        const groupElement = getPanelGroupElement(groupId);\n        assert(groupElement != null, `No group found for id \"${groupId}\"`);\n        const handles = getResizeHandleElementsForGroup(groupId);\n        assert(handles);\n        const cleanupFunctions = handles.map((handle)=>{\n            const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n            assert(handleId);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray);\n            if (idBefore == null || idAfter == null) {\n                return ()=>{};\n            }\n            const onKeyDown = (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                switch(event.key){\n                    case \"Enter\":\n                        {\n                            event.preventDefault();\n                            const index = panelDataArray.findIndex((panelData)=>panelData.id === idBefore);\n                            if (index >= 0) {\n                                const panelData = panelDataArray[index];\n                                assert(panelData);\n                                const size = layout[index];\n                                const { collapsedSize = 0, collapsible, minSize = 0 } = panelData.constraints;\n                                if (size != null && collapsible) {\n                                    const nextLayout = adjustLayoutByDelta({\n                                        delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                                        layout,\n                                        panelConstraints: panelDataArray.map((panelData)=>panelData.constraints),\n                                        pivotIndices: determinePivotIndices(groupId, handleId),\n                                        trigger: \"keyboard\"\n                                    });\n                                    if (layout !== nextLayout) {\n                                        setLayout(nextLayout);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n            };\n            handle.addEventListener(\"keydown\", onKeyDown);\n            return ()=>{\n                handle.removeEventListener(\"keydown\", onKeyDown);\n            };\n        });\n        return ()=>{\n            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());\n        };\n    }, [\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray,\n        setLayout\n    ]);\n}\nfunction areEqual(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n    for(let index = 0; index < arrayA.length; index++){\n        if (arrayA[index] !== arrayB[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\nfunction getResizeEventCursorPosition(direction, event) {\n    const isHorizontal = direction === \"horizontal\";\n    if (isMouseEvent(event)) {\n        return isHorizontal ? event.clientX : event.clientY;\n    } else if (isTouchEvent(event)) {\n        const firstTouch = event.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    } else {\n        throw Error(`Unsupported event type \"${event.type}\"`);\n    }\n}\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState) {\n    const isHorizontal = direction === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n    assert(groupId);\n    let { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(direction, event);\n    const groupElement = getPanelGroupElement(groupId);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy) {\n    if (isKeyDown(event)) {\n        const isHorizontal = direction === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        } else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch(event.key){\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    } else {\n        if (initialDragState == null) {\n            return 0;\n        }\n        return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState);\n    }\n}\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index)=>{\n        const panelData = panelsArray[index];\n        assert(panelData);\n        const { callbacks, constraints, id: panelId } = panelData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n        if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n            panelIdToLastNotifiedSizeMap[panelId] = size;\n            const { onCollapse, onExpand, onResize } = callbacks;\n            if (onResize) {\n                onResize(size, lastNotifiedSize);\n            }\n            if (collapsible && (onCollapse || onExpand)) {\n                if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n                    onExpand();\n                }\n                if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {\n                    onCollapse();\n                }\n            }\n        }\n    });\n}\nfunction compareLayouts(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    } else {\n        for(let index = 0; index < a.length; index++){\n            if (a[index] != b[index]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({ dragState, layout, panelData, panelIndex, precision = 3 }) {\n    const size = layout[panelIndex];\n    let flexGrow;\n    if (panelData.length === 1) {\n        flexGrow = \"1\";\n    } else if (size == null) {\n        // Initial render (before panels have registered themselves)\n        flexGrow = \"1\";\n    } else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined\n    };\n}\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n    switch(state){\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\nfunction resetGlobalCursorStyle() {\n    if (element !== null) {\n        document.head.removeChild(element);\n        currentState = null;\n        element = null;\n    }\n}\nfunction setGlobalCursorStyle(state) {\n    if (currentState === state) {\n        return;\n    }\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = document.createElement(\"style\");\n        document.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    let callable = (...args)=>{\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(()=>{\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n    try {\n        if (typeof localStorage !== \"undefined\") {\n            // Bypass this check for future calls\n            storageObject.getItem = (name)=>{\n                return localStorage.getItem(name);\n            };\n            storageObject.setItem = (name, value)=>{\n                localStorage.setItem(name, value);\n            };\n        } else {\n            throw new Error(\"localStorage not supported in this environment\");\n        }\n    } catch (error) {\n        console.error(error);\n        storageObject.getItem = ()=>null;\n        storageObject.setItem = ()=>{};\n    }\n}\nfunction getPanelGroupKey(autoSaveId) {\n    return `react-resizable-panels:${autoSaveId}`;\n}\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n    return panels.map((panel)=>{\n        const { constraints, id, idIsFromProps, order } = panel;\n        if (idIsFromProps) {\n            return id;\n        } else {\n            return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n        }\n    }).sort((a, b)=>a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n    try {\n        const panelGroupKey = getPanelGroupKey(autoSaveId);\n        const serialized = storage.getItem(panelGroupKey);\n        if (serialized) {\n            const parsed = JSON.parse(serialized);\n            if (typeof parsed === \"object\" && parsed != null) {\n                return parsed;\n            }\n        }\n    } catch (error) {}\n    return null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n    var _loadSerializedPanelG2;\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const panelKey = getPanelKey(panels);\n    const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n    state[panelKey] = {\n        expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n        layout: sizes\n    };\n    try {\n        storage.setItem(panelGroupKey, JSON.stringify(state));\n    } catch (error) {\n        console.error(error);\n    }\n}\nfunction validatePanelConstraints({ panelConstraints: panelConstraintsArray, panelId, panelIndex }) {\n    {\n        const warnings = [];\n        const panelConstraints = panelConstraintsArray[panelIndex];\n        assert(panelConstraints);\n        const { collapsedSize = 0, defaultSize, maxSize = 100, minSize = 0 } = panelConstraints;\n        if (minSize > maxSize) {\n            warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n        }\n        if (defaultSize != null) {\n            if (defaultSize < 0) {\n                warnings.push(\"default size should not be less than 0\");\n            } else if (defaultSize < minSize) {\n                warnings.push(\"default size should not be less than min size\");\n            }\n            if (defaultSize > 100) {\n                warnings.push(\"default size should not be greater than 100\");\n            } else if (defaultSize > maxSize) {\n                warnings.push(\"default size should not be greater than max size\");\n            }\n        }\n        if (collapsedSize > minSize) {\n            warnings.push(\"collapsed size should not be greater than min size\");\n        }\n        if (warnings.length > 0) {\n            const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n            console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n            return false;\n        }\n    }\n    return true;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({ layout: prevLayout, panelConstraints }) {\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current)=>accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== panelConstraints.length) {\n        throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size)=>`${size}%`).join(\", \")}`);\n    } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n        // This is not ideal so we should warn about it, but it may be recoverable in some cases\n        // (especially if the amount is small)\n        {\n            console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size)=>`${size}%`).join(\", \")}. Layout normalization will be applied.`);\n        }\n        for(let index = 0; index < panelConstraints.length; index++){\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each panel's constraints\n    for(let index = 0; index < panelConstraints.length; index++){\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePanel({\n            panelConstraints,\n            panelIndex: index,\n            size: unsafeSize\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any panel(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!fuzzyNumbersEqual(remainingSize, 0)) {\n        for(let index = 0; index < panelConstraints.length; index++){\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePanel({\n                panelConstraints,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (fuzzyNumbersEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n    getItem: (name)=>{\n        initializeDefaultStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value)=>{\n        initializeDefaultStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({ autoSaveId = null, children, className: classNameFromProps = \"\", direction, forwardedRef, id: idFromProps = null, onLayout = null, keyboardResizeBy = null, storage = defaultStorage, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const groupId = useUniqueId(idFromProps);\n    const [dragState, setDragState] = useState(null);\n    const [layout, setLayout] = useState([]);\n    const panelIdToLastNotifiedSizeMapRef = useRef({});\n    const panelSizeBeforeCollapseRef = useRef(new Map());\n    const prevDeltaRef = useRef(0);\n    const committedValuesRef = useRef({\n        autoSaveId,\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout,\n        storage\n    });\n    const eagerValuesRef = useRef({\n        layout,\n        panelDataArray: [],\n        panelDataArrayChanged: false\n    });\n    const devWarningsRef = useRef({\n        didLogIdAndOrderWarning: false,\n        didLogPanelConstraintsWarning: false,\n        prevPanelIds: []\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            getId: ()=>committedValuesRef.current.id,\n            getLayout: ()=>{\n                const { layout } = eagerValuesRef.current;\n                return layout;\n            },\n            setLayout: (unsafeLayout)=>{\n                const { onLayout } = committedValuesRef.current;\n                const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n                const safeLayout = validatePanelGroupLayout({\n                    layout: unsafeLayout,\n                    panelConstraints: panelDataArray.map((panelData)=>panelData.constraints)\n                });\n                if (!areEqual(prevLayout, safeLayout)) {\n                    setLayout(safeLayout);\n                    eagerValuesRef.current.layout = safeLayout;\n                    if (onLayout) {\n                        onLayout(safeLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }), []);\n    useWindowSplitterPanelGroupBehavior({\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray: eagerValuesRef.current.panelDataArray,\n        setLayout\n    });\n    useEffect(()=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        // If this panel has been configured to persist sizing information, save sizes to local storage.\n        if (autoSaveId) {\n            if (layout.length === 0 || layout.length !== panelDataArray.length) {\n                return;\n            }\n            let debouncedSave = debounceMap[autoSaveId];\n            // Limit the frequency of localStorage updates.\n            if (debouncedSave == null) {\n                debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n                debounceMap[autoSaveId] = debouncedSave;\n            }\n            // Clone mutable data before passing to the debounced function,\n            // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n            const clonedPanelDataArray = [\n                ...panelDataArray\n            ];\n            const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n            debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n        }\n    }, [\n        autoSaveId,\n        layout,\n        storage\n    ]);\n    // DEV warnings\n    useEffect(()=>{\n        {\n            const { panelDataArray } = eagerValuesRef.current;\n            const { didLogIdAndOrderWarning, didLogPanelConstraintsWarning, prevPanelIds } = devWarningsRef.current;\n            if (!didLogIdAndOrderWarning) {\n                const panelIds = panelDataArray.map(({ id })=>id);\n                devWarningsRef.current.prevPanelIds = panelIds;\n                const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n                if (panelsHaveChanged) {\n                    if (panelDataArray.find(({ idIsFromProps, order })=>!idIsFromProps || order == null)) {\n                        devWarningsRef.current.didLogIdAndOrderWarning = true;\n                        console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n                    }\n                }\n            }\n            if (!didLogPanelConstraintsWarning) {\n                const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n                for(let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++){\n                    const panelData = panelDataArray[panelIndex];\n                    assert(panelData);\n                    const isValid = validatePanelConstraints({\n                        panelConstraints,\n                        panelId: panelData.id,\n                        panelIndex\n                    });\n                    if (!isValid) {\n                        devWarningsRef.current.didLogPanelConstraintsWarning = true;\n                        break;\n                    }\n                }\n            }\n        }\n    });\n    // External APIs are safe to memoize via committed values ref\n    const collapsePanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            assert(panelSize != null);\n            if (panelSize !== collapsedSize) {\n                // Store size before collapse;\n                // This is the size that gets restored if the expand() API is used.\n                panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    layout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const expandPanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, minSize = 0, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            if (panelSize === collapsedSize) {\n                // Restore this panel to the size it was before it was collapsed, if possible.\n                const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n                const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    layout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const getPanelSize = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null);\n        return panelSize;\n    }, []);\n    // This API should never read from committedValuesRef\n    const getPanelStyle = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n        return computePanelFlexBoxStyle({\n            dragState,\n            layout,\n            panelData: panelDataArray,\n            panelIndex\n        });\n    }, [\n        dragState,\n        layout\n    ]);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelCollapsed = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        return collapsible === true && panelSize === collapsedSize;\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelExpanded = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null);\n        return !collapsible || panelSize > collapsedSize;\n    }, []);\n    const registerPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        panelDataArray.push(panelData);\n        panelDataArray.sort((panelA, panelB)=>{\n            const orderA = panelA.order;\n            const orderB = panelB.order;\n            if (orderA == null && orderB == null) {\n                return 0;\n            } else if (orderA == null) {\n                return -1;\n            } else if (orderB == null) {\n                return 1;\n            } else {\n                return orderA - orderB;\n            }\n        });\n        eagerValuesRef.current.panelDataArrayChanged = true;\n    }, []);\n    const registerResizeHandle = useCallback((dragHandleId)=>{\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const { direction, dragState, id: groupId, keyboardResizeBy, onLayout } = committedValuesRef.current;\n            const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n            const { initialLayout } = dragState !== null && dragState !== void 0 ? dragState : {};\n            const pivotIndices = determinePivotIndices(groupId, dragHandleId);\n            let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy);\n            if (delta === 0) {\n                return;\n            }\n            // Support RTL layouts\n            const isHorizontal = direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n                panelConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n            });\n            const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Panel sizes might not changeâ€“\n                // but updating cursor in this scenario would cause a flicker.\n                if (prevDeltaRef.current != delta) {\n                    prevDeltaRef.current = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the panel any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n                        } else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n                        }\n                    } else {\n                        // Reset the cursor style to the the normal resize cursor.\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n                    }\n                }\n            }\n            if (layoutChanged) {\n                setLayout(nextLayout);\n                eagerValuesRef.current.layout = nextLayout;\n                if (onLayout) {\n                    onLayout(nextLayout);\n                }\n                callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n            }\n        };\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const resizePanel = useCallback((panelData, unsafePanelSize)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n        const { panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n        assert(panelSize != null);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n            eagerValuesRef.current.layout = nextLayout;\n            if (onLayout) {\n                onLayout(nextLayout);\n            }\n            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n    }, []);\n    const startDragging = useCallback((dragHandleId, event)=>{\n        const { direction } = committedValuesRef.current;\n        const { layout } = eagerValuesRef.current;\n        const handleElement = getResizeHandleElement(dragHandleId);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n        setDragState({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout\n        });\n    }, []);\n    const stopDragging = useCallback(()=>{\n        resetGlobalCursorStyle();\n        setDragState(null);\n    }, []);\n    const unregisterPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const index = findPanelDataIndex(panelDataArray, panelData);\n        if (index >= 0) {\n            panelDataArray.splice(index, 1);\n            // TRICKY\n            // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n            // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n            // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n            delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n            eagerValuesRef.current.panelDataArrayChanged = true;\n        }\n    }, []);\n    const context = useMemo(()=>({\n            collapsePanel,\n            direction,\n            dragState,\n            expandPanel,\n            getPanelSize,\n            getPanelStyle,\n            groupId,\n            isPanelCollapsed,\n            isPanelExpanded,\n            registerPanel,\n            registerResizeHandle,\n            resizePanel,\n            startDragging,\n            stopDragging,\n            unregisterPanel\n        }), [\n        collapsePanel,\n        dragState,\n        direction,\n        expandPanel,\n        getPanelSize,\n        getPanelStyle,\n        groupId,\n        isPanelCollapsed,\n        isPanelExpanded,\n        registerPanel,\n        registerResizeHandle,\n        resizePanel,\n        startDragging,\n        stopDragging,\n        unregisterPanel\n    ]);\n    const style = {\n        display: \"flex\",\n        flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n    };\n    return createElement(PanelGroupContext.Provider, {\n        value: context\n    }, createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel-group\": \"\",\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId\n    }));\n}\nconst PanelGroup = forwardRef((props, ref)=>createElement(PanelGroupWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n    return panelDataArray.findIndex((prevPanelData)=>prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n    const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    const isLastPanel = panelIndex === panelDataArray.length - 1;\n    const pivotIndices = isLastPanel ? [\n        panelIndex - 1,\n        panelIndex\n    ] : [\n        panelIndex,\n        panelIndex + 1\n    ];\n    const panelSize = layout[panelIndex];\n    return {\n        ...panelConstraints,\n        panelSize,\n        pivotIndices\n    };\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler }) {\n    useEffect(()=>{\n        if (disabled || resizeHandler == null) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(handleId);\n        if (handleElement == null) {\n            return;\n        }\n        const onKeyDown = (event)=>{\n            if (event.defaultPrevented) {\n                return;\n            }\n            switch(event.key){\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"End\":\n                case \"Home\":\n                    {\n                        event.preventDefault();\n                        resizeHandler(event);\n                        break;\n                    }\n                case \"F6\":\n                    {\n                        event.preventDefault();\n                        const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n                        assert(groupId);\n                        const handles = getResizeHandleElementsForGroup(groupId);\n                        const index = getResizeHandleElementIndex(groupId, handleId);\n                        assert(index !== null);\n                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n                        const nextHandle = handles[nextIndex];\n                        nextHandle.focus();\n                        break;\n                    }\n            }\n        };\n        handleElement.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            handleElement.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        handleId,\n        resizeHandler\n    ]);\n}\nfunction PanelResizeHandle({ children = null, className: classNameFromProps = \"\", disabled = false, id: idFromProps, onDragging, style: styleFromProps = {}, tabIndex = 0, tagName: Type = \"div\", ...rest }) {\n    const divElementRef = useRef(null);\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onDragging\n    });\n    useEffect(()=>{\n        callbacksRef.current.onDragging = onDragging;\n    });\n    const panelGroupContext = useContext(PanelGroupContext);\n    if (panelGroupContext === null) {\n        throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n    }\n    const { direction, dragState, groupId, registerResizeHandle, startDragging, stopDragging } = panelGroupContext;\n    const resizeHandleId = useUniqueId(idFromProps);\n    const isDragging = (dragState === null || dragState === void 0 ? void 0 : dragState.dragHandleId) === resizeHandleId;\n    const [isFocused, setIsFocused] = useState(false);\n    const [resizeHandler, setResizeHandler] = useState(null);\n    const stopDraggingAndBlur = useCallback(()=>{\n        // Clicking on the drag handle shouldn't leave it focused;\n        // That would cause the PanelGroup to think it was still active.\n        const divElement = divElementRef.current;\n        assert(divElement);\n        divElement.blur();\n        stopDragging();\n        const { onDragging } = callbacksRef.current;\n        if (onDragging) {\n            onDragging(false);\n        }\n    }, [\n        stopDragging\n    ]);\n    useEffect(()=>{\n        if (disabled) {\n            setResizeHandler(null);\n        } else {\n            const resizeHandler = registerResizeHandle(resizeHandleId);\n            setResizeHandler(()=>resizeHandler);\n        }\n    }, [\n        disabled,\n        resizeHandleId,\n        registerResizeHandle\n    ]);\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || !isDragging) {\n            return;\n        }\n        const onMove = (event)=>{\n            resizeHandler(event);\n        };\n        const onMouseLeave = (event)=>{\n            resizeHandler(event);\n        };\n        const divElement = divElementRef.current;\n        assert(divElement);\n        const targetDocument = divElement.ownerDocument;\n        targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n        targetDocument.body.addEventListener(\"mousemove\", onMove);\n        targetDocument.body.addEventListener(\"touchmove\", onMove);\n        targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n        window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n        window.addEventListener(\"touchend\", stopDraggingAndBlur);\n        return ()=>{\n            targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n            targetDocument.body.removeEventListener(\"mousemove\", onMove);\n            targetDocument.body.removeEventListener(\"touchmove\", onMove);\n            targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n            window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n            window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n        };\n    }, [\n        direction,\n        disabled,\n        isDragging,\n        resizeHandler,\n        stopDraggingAndBlur\n    ]);\n    useWindowSplitterResizeHandlerBehavior({\n        disabled,\n        handleId: resizeHandleId,\n        resizeHandler\n    });\n    const style = {\n        cursor: getCursorStyle(direction),\n        touchAction: \"none\",\n        userSelect: \"none\"\n    };\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        onBlur: ()=>setIsFocused(false),\n        onFocus: ()=>setIsFocused(true),\n        onMouseDown: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const callbacks = callbacksRef.current;\n            assert(callbacks);\n            const { onDragging } = callbacks;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        onMouseUp: stopDraggingAndBlur,\n        onTouchCancel: stopDraggingAndBlur,\n        onTouchEnd: stopDraggingAndBlur,\n        onTouchStart: (event)=>{\n            startDragging(resizeHandleId, event.nativeEvent);\n            const callbacks = callbacksRef.current;\n            assert(callbacks);\n            const { onDragging } = callbacks;\n            if (onDragging) {\n                onDragging(true);\n            }\n        },\n        ref: divElementRef,\n        role: \"separator\",\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        tabIndex,\n        // CSS selectors\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId,\n        \"data-resize-handle\": \"\",\n        \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n        \"data-panel-resize-handle-enabled\": !disabled,\n        \"data-panel-resize-handle-id\": resizeHandleId\n    });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBRS9CLGtHQUFrRztBQUVsRyxpREFBaUQ7QUFFakQsTUFBTSxFQUNKQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxTQUFTLEVBQ1RDLG1CQUFtQixFQUNuQkMsZUFBZSxFQUNmQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsUUFBUSxFQUNULEdBQUdaLGtDQUFLQTtBQUVULGdGQUFnRjtBQUNoRixNQUFNYSxRQUFRYixrQ0FBSyxDQUFDLFFBQVFjLFFBQVEsR0FBRztBQUV2QyxNQUFNQyxvQkFBb0JiLGNBQWM7QUFDeENhLGtCQUFrQkMsV0FBVyxHQUFHO0FBRWhDLE1BQU1DLGVBQWUsT0FBT0osVUFBVSxhQUFhQSxRQUFRLElBQU07QUFDakUsSUFBSUssVUFBVTtBQUNkLFNBQVNDLFlBQVlDLGVBQWUsSUFBSTtJQUN0QyxNQUFNQyxjQUFjSjtJQUNwQixNQUFNSyxRQUFRWCxPQUFPUyxnQkFBZ0JDLGVBQWU7SUFDcEQsSUFBSUMsTUFBTUMsT0FBTyxLQUFLLE1BQU07UUFDMUJELE1BQU1DLE9BQU8sR0FBRyxLQUFLTDtJQUN2QjtJQUNBLE9BQU9FLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJQSxlQUFlRSxNQUFNQyxPQUFPO0FBQ3hGO0FBRUEsU0FBU0Msc0JBQXNCLEVBQzdCQyxRQUFRLEVBQ1JDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLElBQUlDLFdBQVcsRUFDZkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUss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LGdCQUFnQjdLLE1BQU1pTSxXQUFXO1lBQy9DLE1BQU16UyxZQUFZbVIsYUFBYXRULE9BQU87WUFDdEN5RCxPQUFPdEI7WUFDUCxNQUFNLEVBQ0pnUixVQUFVLEVBQ1gsR0FBR2hSO1lBQ0osSUFBSWdSLFlBQVk7Z0JBQ2RBLFdBQVc7WUFDYjtRQUNGO1FBQ0EwQixXQUFXaEI7UUFDWGlCLGVBQWVqQjtRQUNma0IsWUFBWWxCO1FBQ1ptQixjQUFjck0sQ0FBQUE7WUFDWnlKLGNBQWNvQixnQkFBZ0I3SyxNQUFNaU0sV0FBVztZQUMvQyxNQUFNelMsWUFBWW1SLGFBQWF0VCxPQUFPO1lBQ3RDeUQsT0FBT3RCO1lBQ1AsTUFBTSxFQUNKZ1IsVUFBVSxFQUNYLEdBQUdoUjtZQUNKLElBQUlnUixZQUFZO2dCQUNkQSxXQUFXO1lBQ2I7UUFDRjtRQUNBM1AsS0FBSzZQO1FBQ0w0QixNQUFNO1FBQ05oVSxPQUFPO1lBQ0wsR0FBR0EsS0FBSztZQUNSLEdBQUdDLGNBQWM7UUFDbkI7UUFDQWtTO1FBQ0EsZ0JBQWdCO1FBQ2hCLDhCQUE4QnZKO1FBQzlCLHVCQUF1QmpJO1FBQ3ZCLHNCQUFzQjtRQUN0Qiw2QkFBNkI2UixhQUFhLFlBQVlDLFlBQVksYUFBYXBSO1FBQy9FLG9DQUFvQyxDQUFDd1E7UUFDckMsK0JBQStCVTtJQUNqQztBQUNGO0FBQ0FOLGtCQUFrQnpULFdBQVcsR0FBRztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5kZXZlbG9wbWVudC5ub2RlLmVzbS5qcz8xNTc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVGhpcyBtb2R1bGUgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIFdlYnBhY2sgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5jb25zdCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGNyZWF0ZVJlZixcbiAgZm9yd2FyZFJlZixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlXG59ID0gUmVhY3Q7XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXTtcblxuY29uc3QgUGFuZWxHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuUGFuZWxHcm91cENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBDb250ZXh0XCI7XG5cbmNvbnN0IHdyYXBwZWRVc2VJZCA9IHR5cGVvZiB1c2VJZCA9PT0gXCJmdW5jdGlvblwiID8gdXNlSWQgOiAoKSA9PiBudWxsO1xubGV0IGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQoaWRGcm9tUGFyYW1zID0gbnVsbCkge1xuICBjb25zdCBpZEZyb21Vc2VJZCA9IHdyYXBwZWRVc2VJZCgpO1xuICBjb25zdCBpZFJlZiA9IHVzZVJlZihpZEZyb21QYXJhbXMgfHwgaWRGcm9tVXNlSWQgfHwgbnVsbCk7XG4gIGlmIChpZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaWRSZWYuY3VycmVudCA9IFwiXCIgKyBjb3VudGVyKys7XG4gIH1cbiAgcmV0dXJuIGlkRnJvbVBhcmFtcyAhPT0gbnVsbCAmJiBpZEZyb21QYXJhbXMgIT09IHZvaWQgMCA/IGlkRnJvbVBhcmFtcyA6IGlkUmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIFBhbmVsV2l0aEZvcndhcmRlZFJlZih7XG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGNvbGxhcHNlZFNpemUsXG4gIGNvbGxhcHNpYmxlLFxuICBkZWZhdWx0U2l6ZSxcbiAgZm9yd2FyZGVkUmVmLFxuICBpZDogaWRGcm9tUHJvcHMsXG4gIG1heFNpemUsXG4gIG1pblNpemUsXG4gIG9uQ29sbGFwc2UsXG4gIG9uRXhwYW5kLFxuICBvblJlc2l6ZSxcbiAgb3JkZXIsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBQYW5lbCBjb21wb25lbnRzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgUGFuZWxHcm91cCBjb250YWluZXJgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBleHBhbmRQYW5lbCxcbiAgICBnZXRQYW5lbFNpemUsXG4gICAgZ2V0UGFuZWxTdHlsZSxcbiAgICBncm91cElkLFxuICAgIGlzUGFuZWxDb2xsYXBzZWQsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZXNpemVQYW5lbCxcbiAgICB1bnJlZ2lzdGVyUGFuZWxcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHBhbmVsSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IHBhbmVsRGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBvbkNvbGxhcHNlLFxuICAgICAgb25FeHBhbmQsXG4gICAgICBvblJlc2l6ZVxuICAgIH0sXG4gICAgY29uc3RyYWludHM6IHtcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIGRlZmF1bHRTaXplLFxuICAgICAgbWF4U2l6ZSxcbiAgICAgIG1pblNpemVcbiAgICB9LFxuICAgIGlkOiBwYW5lbElkLFxuICAgIGlkSXNGcm9tUHJvcHM6IGlkRnJvbVByb3BzICE9PSB1bmRlZmluZWQsXG4gICAgb3JkZXJcbiAgfSk7XG4gIGNvbnN0IGRldldhcm5pbmdzUmVmID0gdXNlUmVmKHtcbiAgICBkaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nOiBmYWxzZVxuICB9KTtcblxuICAvLyBOb3JtYWxseSB3ZSB3b3VsZG4ndCBsb2cgYSB3YXJuaW5nIGR1cmluZyByZW5kZXIsXG4gIC8vIGJ1dCBlZmZlY3RzIGRvbid0IHJ1biBvbiB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBkbyBpdCB0aGVyZVxuICB7XG4gICAgaWYgKCFkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmcpIHtcbiAgICAgIGlmIChkZWZhdWx0U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZyA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgZGVmYXVsdFNpemUgcHJvcCByZWNvbW1lbmRlZCB0byBhdm9pZCBsYXlvdXQgc2hpZnQgYWZ0ZXIgc2VydmVyIHJlbmRlcmluZ2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICBjb2xsYXBzZTogKCkgPT4ge1xuICAgICAgY29sbGFwc2VQYW5lbChwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBleHBhbmQ6ICgpID0+IHtcbiAgICAgIGV4cGFuZFBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGdldElkKCkge1xuICAgICAgcmV0dXJuIHBhbmVsSWQ7XG4gICAgfSxcbiAgICBnZXRTaXplKCkge1xuICAgICAgcmV0dXJuIGdldFBhbmVsU2l6ZShwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBpc0NvbGxhcHNlZCgpIHtcbiAgICAgIHJldHVybiBpc1BhbmVsQ29sbGFwc2VkKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGlzRXhwYW5kZWQoKSB7XG4gICAgICByZXR1cm4gIWlzUGFuZWxDb2xsYXBzZWQocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgcmVzaXplOiBzaXplID0+IHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBzaXplKTtcbiAgICB9XG4gIH0pLCBbY29sbGFwc2VQYW5lbCwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgaXNQYW5lbENvbGxhcHNlZCwgcGFuZWxJZCwgcmVzaXplUGFuZWxdKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRQYW5lbFN0eWxlKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWxcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtaWRcIjogcGFuZWxJZCxcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICAvLyBlMmUgdGVzdCBhdHRyaWJ1dGVzXG4gICAgXCJkYXRhLXBhbmVsLWNvbGxhcHNpYmxlXCI6IGNvbGxhcHNpYmxlIHx8IHVuZGVmaW5lZCAsXG4gICAgXCJkYXRhLXBhbmVsLXNpemVcIjogcGFyc2VGbG9hdChcIlwiICsgc3R5bGUuZmxleEdyb3cpLnRvRml4ZWQoMSkgXG4gIH0pO1xufVxuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxcIjtcblBhbmVsLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsKVwiO1xuXG5mdW5jdGlvbiBhc3NlcnQoZXhwZWN0ZWRDb25kaXRpb24sIG1lc3NhZ2UgPSBcIkFzc2VydGlvbiBmYWlsZWQhXCIpIHtcbiAgaWYgKCFleHBlY3RlZENvbmRpdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuY29uc3QgUFJFQ0lTSU9OID0gMTA7XG5cbmZ1bmN0aW9uIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMgPSBQUkVDSVNJT04pIHtcbiAgYWN0dWFsID0gcGFyc2VGbG9hdChhY3R1YWwudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBleHBlY3RlZCA9IHBhcnNlRmxvYXQoZXhwZWN0ZWQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBjb25zdCBkZWx0YSA9IGFjdHVhbCAtIGV4cGVjdGVkO1xuICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gMSA6IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZ1enp5TnVtYmVyc0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiBmdXp6eUNvbXBhcmVOdW1iZXJzKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSA9PT0gMDtcbn1cblxuLy8gUGFuZWwgc2l6ZSBtdXN0IGJlIGluIHBlcmNlbnRhZ2VzOyBwaXhlbCB2YWx1ZXMgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWRcbmZ1bmN0aW9uIHJlc2l6ZVBhbmVsKHtcbiAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICBwYW5lbEluZGV4LFxuICBzaXplXG59KSB7XG4gIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbcGFuZWxJbmRleF07XG4gIGFzc2VydChwYW5lbENvbnN0cmFpbnRzICE9IG51bGwpO1xuICBsZXQge1xuICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgIGNvbGxhcHNpYmxlLFxuICAgIG1heFNpemUgPSAxMDAsXG4gICAgbWluU2l6ZSA9IDBcbiAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG4gIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKHNpemUsIG1pblNpemUpIDwgMCkge1xuICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgLy8gQ29sbGFwc2libGUgcGFuZWxzIHNob3VsZCBzbmFwIGNsb3NlZCBvciBvcGVuIG9ubHkgb25jZSB0aGV5IGNyb3NzIHRoZSBoYWxmd2F5IHBvaW50IGJldHdlZW4gY29sbGFwc2VkIGFuZCBtaW4gc2l6ZS5cbiAgICAgIGNvbnN0IGhhbGZ3YXlQb2ludCA9IChjb2xsYXBzZWRTaXplICsgbWluU2l6ZSkgLyAyO1xuICAgICAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMoc2l6ZSwgaGFsZndheVBvaW50KSA8IDApIHtcbiAgICAgICAgc2l6ZSA9IGNvbGxhcHNlZFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICB9XG4gIHNpemUgPSBNYXRoLm1pbihtYXhTaXplLCBzaXplKTtcbiAgc2l6ZSA9IHBhcnNlRmxvYXQoc2l6ZS50b0ZpeGVkKFBSRUNJU0lPTikpO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gIGRlbHRhLFxuICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGl2b3RJbmRpY2VzLFxuICB0cmlnZ2VyXG59KSB7XG4gIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YSwgMCkpIHtcbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuICBjb25zdCBuZXh0TGF5b3V0ID0gWy4uLnByZXZMYXlvdXRdO1xuICBjb25zdCBbZmlyc3RQaXZvdEluZGV4LCBzZWNvbmRQaXZvdEluZGV4XSA9IHBpdm90SW5kaWNlcztcbiAgYXNzZXJ0KGZpcnN0UGl2b3RJbmRleCAhPSBudWxsKTtcbiAgYXNzZXJ0KHNlY29uZFBpdm90SW5kZXggIT0gbnVsbCk7XG4gIGxldCBkZWx0YUFwcGxpZWQgPSAwO1xuXG4gIC8vY29uc3QgREVCVUcgPSBbXTtcbiAgLy9ERUJVRy5wdXNoKGBhZGp1c3RMYXlvdXRCeURlbHRhKCkgJHtwcmV2TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy9ERUJVRy5wdXNoKGAgIGRlbHRhOiAke2RlbHRhfWApO1xuICAvL0RFQlVHLnB1c2goYCAgcGl2b3RJbmRpY2VzOiAke3Bpdm90SW5kaWNlcy5qb2luKFwiLCBcIil9YCk7XG4gIC8vREVCVUcucHVzaChgICB0cmlnZ2VyOiAke3RyaWdnZXJ9YCk7XG4gIC8vREVCVUcucHVzaChcIlwiKTtcblxuICAvLyBBIHJlc2l6aW5nIHBhbmVsIGFmZmVjdHMgdGhlIHBhbmVscyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gIC8vXG4gIC8vIEEgbmVnYXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXNpemUgaGFuZGxlIHNob3VsZCBncm93L2V4cGFuZCBieSBkZWNyZWFzaW5nIGl0cyBvZmZzZXQuXG4gIC8vIE90aGVyIHBhbmVscyBtYXkgYWxzbyBuZWVkIHRvIHNocmluay9jb250cmFjdCAoYW5kIHNoaWZ0KSB0byBtYWtlIHJvb20sIGRlcGVuZGluZyBvbiB0aGUgbWluIHdlaWdodHMuXG4gIC8vXG4gIC8vIEEgcG9zaXRpdmUgZGVsdGEgbWVhbnMgdGhlIHBhbmVsKHMpIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgcmVzaXplIGhhbmRsZSBzaG91bGQgXCJleHBhbmRcIi5cbiAgLy8gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgc2hyaW5raW5nL2NvbnRyYWN0aW5nIChhbmQgc2hpZnRpbmcpIG9uZSBvciBtb3JlIG9mIHRoZSBwYW5lbHMgYWZ0ZXIgdGhlIHJlc2l6ZSBoYW5kbGUuXG5cbiAge1xuICAgIC8vIElmIHRoaXMgaXMgYSByZXNpemUgdHJpZ2dlcmVkIGJ5IGEga2V5Ym9hcmQgZXZlbnQsIG91ciBsb2dpYyBmb3IgZXhwYW5kaW5nL2NvbGxhcHNpbmcgaXMgZGlmZmVyZW50LlxuICAgIC8vIFdlIG5vIGxvbmdlciBjaGVjayB0aGUgaGFsZndheSB0aHJlc2hvbGQgYmVjYXVzZSB0aGlzIG1heSBwcmV2ZW50IHRoZSBwYW5lbCBmcm9tIGV4cGFuZGluZyBhdCBhbGwuXG4gICAgaWYgKHRyaWdnZXIgPT09IFwia2V5Ym9hcmRcIikge1xuICAgICAge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZXhwYW5kIGEgY29sbGFwc2VkIHBhbmVsXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzKTtcblxuICAgICAgICAvL0RFQlVHLnB1c2goYGVkZ2UgY2FzZSBjaGVjayAxOiAke2luZGV4fWApO1xuICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gY29sbGFwc2libGU/ICR7Y29uc3RyYWludHMuY29sbGFwc2libGV9YCk7XG4gICAgICAgIGlmIChwYW5lbENvbnN0cmFpbnRzLmNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgY29uc3QgcHJldlNpemUgPSBwcmV2TGF5b3V0W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCk7XG4gICAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtpbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgICB9ID0gcGFuZWxDb25zdHJhaW50cztcbiAgICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbERlbHRhID0gbWluU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGV4cGFuZCBkZWx0YTogJHtsb2NhbERlbHRhfWApO1xuXG4gICAgICAgICAgICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhsb2NhbERlbHRhLCBNYXRoLmFicyhkZWx0YSkpID4gMCkge1xuICAgICAgICAgICAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBsb2NhbERlbHRhIDogbG9jYWxEZWx0YTtcbiAgICAgICAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGRlbHRhOiAke2RlbHRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBhIHBhbmVsIGF0IGl0cyBtaW5pbXVtIHNpemVcbiAgICAgICAgY29uc3QgaW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29sbGFwc2libGVcbiAgICAgICAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG5cbiAgICAgICAgLy9ERUJVRy5wdXNoKGBlZGdlIGNhc2UgY2hlY2sgMjogJHtpbmRleH1gKTtcbiAgICAgICAgLy9ERUJVRy5wdXNoKGAgIC0+IGNvbGxhcHNpYmxlPyAke2NvbGxhcHNpYmxlfWApO1xuICAgICAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbaW5kZXhdO1xuICAgICAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsKTtcbiAgICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cyk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgICBtaW5TaXplID0gMFxuICAgICAgICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICAgICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgbWluU2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRGVsdGEgPSBwcmV2U2l6ZSAtIGNvbGxhcHNlZFNpemU7XG4gICAgICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gZXhwYW5kIGRlbHRhOiAke2xvY2FsRGVsdGF9YCk7XG5cbiAgICAgICAgICAgIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKGxvY2FsRGVsdGEsIE1hdGguYWJzKGRlbHRhKSkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPCAwID8gMCAtIGxvY2FsRGVsdGEgOiBsb2NhbERlbHRhO1xuICAgICAgICAgICAgICAvL0RFQlVHLnB1c2goYCAgLT4gZGVsdGE6ICR7ZGVsdGF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vREVCVUcucHVzaChcIlwiKTtcbiAgfVxuXG4gIHtcbiAgICAvLyBQcmUtY2FsY3VsYXRlIG1heCBhdmFpbGFibGUgZGVsdGEgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiBvdXIgcGl2b3QuXG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBtYXhpbXVtIGFtb3VudCB3ZSdyZSBhbGxvd2VkIHRvIGV4cGFuZC9jb250cmFjdCB0aGUgcGFuZWxzIGluIHRoZSBwcmltYXJ5IGRpcmVjdGlvbi5cbiAgICAvLyBJZiB0aGlzIGFtb3VudCBpcyBsZXNzIHRoYW4gdGhlIHJlcXVlc3RlZCBkZWx0YSwgYWRqdXN0IHRoZSByZXF1ZXN0ZWQgZGVsdGEuXG4gICAgLy8gSWYgdGhpcyBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVsdGEsIHRoYXQncyB1c2VmdWwgaW5mb3JtYXRpb24gdG9v4oCTXG4gICAgLy8gYXMgYW4gZXhwYW5kaW5nIHBhbmVsIG1pZ2h0IGNoYW5nZSBmcm9tIGNvbGxhcHNlZCB0byBtaW4gc2l6ZS5cblxuICAgIGNvbnN0IGluY3JlbWVudCA9IGRlbHRhIDwgMCA/IDEgOiAtMTtcbiAgICBsZXQgaW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgIGxldCBtYXhBdmFpbGFibGVEZWx0YSA9IDA7XG5cbiAgICAvL0RFQlVHLnB1c2goXCJwcmUgY2FsYy4uLlwiKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcHJldlNpemUgPSBwcmV2TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsKTtcbiAgICAgIGNvbnN0IG1heFNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiAxMDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVsdGEgPSBtYXhTYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgLy9ERUJVRy5wdXNoKGAgICR7aW5kZXh9OiAke3ByZXZTaXplfSAtPiAke21heFNhZmVTaXplfWApO1xuXG4gICAgICBtYXhBdmFpbGFibGVEZWx0YSArPSBkZWx0YTtcbiAgICAgIGluZGV4ICs9IGluY3JlbWVudDtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0RFQlVHLnB1c2goYCAgLT4gbWF4IGF2YWlsYWJsZSBkZWx0YTogJHttYXhBdmFpbGFibGVEZWx0YX1gKTtcbiAgICBjb25zdCBtaW5BYnNEZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKGRlbHRhKSwgTWF0aC5hYnMobWF4QXZhaWxhYmxlRGVsdGEpKTtcbiAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBtaW5BYnNEZWx0YSA6IG1pbkFic0RlbHRhO1xuICAgIC8vREVCVUcucHVzaChgICAtPiBhZGp1c3RlZCBkZWx0YTogJHtkZWx0YX1gKTtcbiAgICAvL0RFQlVHLnB1c2goXCJcIik7XG4gIH1cblxuICB7XG4gICAgLy8gRGVsdGEgYWRkZWQgdG8gYSBwYW5lbCBuZWVkcyB0byBiZSBzdWJ0cmFjdGVkIGZyb20gb3RoZXIgcGFuZWxzICh3aXRoaW4gdGhlIGNvbnN0cmFpbnRzIHRoYXQgdGhvc2UgcGFuZWxzIGFsbG93KS5cblxuICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgIGxldCBpbmRleCA9IHBpdm90SW5kZXg7XG4gICAgd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWx0YVJlbWFpbmluZyA9IE1hdGguYWJzKGRlbHRhKSAtIE1hdGguYWJzKGRlbHRhQXBwbGllZCk7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwpO1xuICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplIC0gZGVsdGFSZW1haW5pbmc7XG4gICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBzYWZlU2l6ZSkpIHtcbiAgICAgICAgZGVsdGFBcHBsaWVkICs9IHByZXZTaXplIC0gc2FmZVNpemU7XG4gICAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgICAgIGlmIChkZWx0YUFwcGxpZWQudG9QcmVjaXNpb24oMykubG9jYWxlQ29tcGFyZShNYXRoLmFicyhkZWx0YSkudG9QcmVjaXNpb24oMyksIHVuZGVmaW5lZCwge1xuICAgICAgICAgIG51bWVyaWM6IHRydWVcbiAgICAgICAgfSkgPj0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0RFQlVHLnB1c2goYGFmdGVyIDE6ICR7bmV4dExheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vREVCVUcucHVzaChgICBkZWx0YUFwcGxpZWQ6ICR7ZGVsdGFBcHBsaWVkfWApO1xuICAvL0RFQlVHLnB1c2goXCJcIik7XG5cbiAgLy8gSWYgd2Ugd2VyZSB1bmFibGUgdG8gcmVzaXplIGFueSBvZiB0aGUgcGFuZWxzIHBhbmVscywgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgLy8gVGhpcyB3aWxsIGVzc2VudGlhbGx5IGJhaWxvdXQgYW5kIGlnbm9yZSBlLmcuIGRyYWdzIHBhc3QgYSBwYW5lbCdzIGJvdW5kYXJpZXNcbiAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKGRlbHRhQXBwbGllZCwgMCkpIHtcbiAgICAvL2NvbnNvbGUubG9nKERFQlVHLmpvaW4oXCJcXG5cIikpO1xuICAgIHJldHVybiBwcmV2TGF5b3V0O1xuICB9XG4gIHtcbiAgICAvLyBOb3cgZGlzdHJpYnV0ZSB0aGUgYXBwbGllZCBkZWx0YSB0byB0aGUgcGFuZWxzIGluIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAgICBjb25zdCBwaXZvdEluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICBjb25zdCBwcmV2U2l6ZSA9IHByZXZMYXlvdXRbcGl2b3RJbmRleF07XG4gICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwpO1xuICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhQXBwbGllZDtcbiAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgIHBhbmVsSW5kZXg6IHBpdm90SW5kZXgsXG4gICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgfSk7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBpdm90IHBhbmVsIGJlZm9yZSwgYnV0IG9ubHkgYnkgdGhlIGFtb3VudCB0aGF0IHN1cnJvdW5kaW5nIHBhbmVscyB3ZXJlIGFibGUgdG8gc2hyaW5rL2NvbnRyYWN0LlxuICAgIG5leHRMYXlvdXRbcGl2b3RJbmRleF0gPSBzYWZlU2l6ZTtcblxuICAgIC8vIEVkZ2UgY2FzZSB3aGVyZSBleHBhbmRpbmcgb3IgY29udHJhY3Rpbmcgb25lIHBhbmVsIGNhdXNlZCBhbm90aGVyIG9uZSB0byBjaGFuZ2UgY29sbGFwc2VkIHN0YXRlXG4gICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChzYWZlU2l6ZSwgdW5zYWZlU2l6ZSkpIHtcbiAgICAgIGxldCBkZWx0YVJlbWFpbmluZyA9IHVuc2FmZVNpemUgLSBzYWZlU2l6ZTtcbiAgICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgICAgbGV0IGluZGV4ID0gcGl2b3RJbmRleDtcbiAgICAgIHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDwgcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhUmVtYWluaW5nO1xuICAgICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgc2FmZVNpemUpKSB7XG4gICAgICAgICAgZGVsdGFSZW1haW5pbmcgLT0gc2FmZVNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YVJlbWFpbmluZywgMCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vREVCVUcucHVzaChgYWZ0ZXIgMjogJHtuZXh0TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy9ERUJVRy5wdXNoKGAgIGRlbHRhQXBwbGllZDogJHtkZWx0YUFwcGxpZWR9YCk7XG4gIC8vREVCVUcucHVzaChcIlwiKTtcblxuICBjb25zdCB0b3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgodG90YWwsIHNpemUpID0+IHNpemUgKyB0b3RhbCwgMCk7XG4gIC8vREVCVUcucHVzaChgdG90YWwgc2l6ZTogJHt0b3RhbFNpemV9YCk7XG4gIC8vY29uc29sZS5sb2coREVCVUcuam9pbihcIlxcblwiKSk7XG5cbiAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbCh0b3RhbFNpemUsIDEwMCkpIHtcbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuICByZXR1cm4gbmV4dExheW91dDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgaWQpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlcy5maW5kSW5kZXgoaGFuZGxlID0+IGhhbmRsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIikgPT09IGlkKTtcbiAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVBpdm90SW5kaWNlcyhncm91cElkLCBkcmFnSGFuZGxlSWQpIHtcbiAgY29uc3QgaW5kZXggPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkKTtcbiAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyBbaW5kZXgsIGluZGV4ICsgMV0gOiBbLTEsIC0xXTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cEVsZW1lbnQoaWQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWdyb3VwXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChpZCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSkge1xuICB2YXIgX3BhbmVsc0FycmF5JGluZGV4JGlkLCBfcGFuZWxzQXJyYXkkaW5kZXgsIF9wYW5lbHNBcnJheSRpZCwgX3BhbmVsc0FycmF5O1xuICBjb25zdCBoYW5kbGUgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGhhbmRsZUlkKTtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlID8gaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkgOiAtMTtcbiAgY29uc3QgaWRCZWZvcmUgPSAoX3BhbmVsc0FycmF5JGluZGV4JGlkID0gKF9wYW5lbHNBcnJheSRpbmRleCA9IHBhbmVsc0FycmF5W2luZGV4XSkgPT09IG51bGwgfHwgX3BhbmVsc0FycmF5JGluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGFuZWxzQXJyYXkkaW5kZXguaWQpICE9PSBudWxsICYmIF9wYW5lbHNBcnJheSRpbmRleCRpZCAhPT0gdm9pZCAwID8gX3BhbmVsc0FycmF5JGluZGV4JGlkIDogbnVsbDtcbiAgY29uc3QgaWRBZnRlciA9IChfcGFuZWxzQXJyYXkkaWQgPSAoX3BhbmVsc0FycmF5ID0gcGFuZWxzQXJyYXlbaW5kZXggKyAxXSkgPT09IG51bGwgfHwgX3BhbmVsc0FycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGFuZWxzQXJyYXkuaWQpICE9PSBudWxsICYmIF9wYW5lbHNBcnJheSRpZCAhPT0gdm9pZCAwID8gX3BhbmVsc0FycmF5JGlkIDogbnVsbDtcbiAgcmV0dXJuIFtpZEJlZm9yZSwgaWRBZnRlcl07XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvd2luZG93c3BsaXR0ZXIvXG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yKHtcbiAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICBlYWdlclZhbHVlc1JlZixcbiAgZ3JvdXBJZCxcbiAgbGF5b3V0LFxuICBwYW5lbERhdGFBcnJheSxcbiAgc2V0TGF5b3V0XG59KSB7XG4gIHVzZVJlZih7XG4gICAgZGlkV2FybkFib3V0TWlzc2luZ1Jlc2l6ZUhhbmRsZTogZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWFnZXJWYWx1ZXMgPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGFzc2VydChlYWdlclZhbHVlcyk7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXM7XG4gICAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cEVsZW1lbnQoZ3JvdXBJZCk7XG4gICAgYXNzZXJ0KGdyb3VwRWxlbWVudCAhPSBudWxsLCBgTm8gZ3JvdXAgZm91bmQgZm9yIGlkIFwiJHtncm91cElkfVwiYCk7XG4gICAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gICAgYXNzZXJ0KGhhbmRsZXMpO1xuICAgIGNvbnN0IGNsZWFudXBGdW5jdGlvbnMgPSBoYW5kbGVzLm1hcChoYW5kbGUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXCIpO1xuICAgICAgYXNzZXJ0KGhhbmRsZUlkKTtcbiAgICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxEYXRhQXJyYXkpO1xuICAgICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYW5lbERhdGFBcnJheS5maW5kSW5kZXgocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5pZCA9PT0gaWRCZWZvcmUpO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsRGF0YSA9IHBhbmVsRGF0YUFycmF5W2luZGV4XTtcbiAgICAgICAgICAgICAgICBhc3NlcnQocGFuZWxEYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gbGF5b3V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgICAgICAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgICAgICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgICAgICAgICB9ID0gcGFuZWxEYXRhLmNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmIChzaXplICE9IG51bGwgJiYgY29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IGZ1enp5TnVtYmVyc0VxdWFsKHNpemUsIGNvbGxhcHNlZFNpemUpID8gbWluU2l6ZSAtIGNvbGxhcHNlZFNpemUgOiBjb2xsYXBzZWRTaXplIC0gc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyksXG4gICAgICAgICAgICAgICAgICAgIHBpdm90SW5kaWNlczogZGV0ZXJtaW5lUGl2b3RJbmRpY2VzKGdyb3VwSWQsIGhhbmRsZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogXCJrZXlib2FyZFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgIT09IG5leHRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cEZ1bmN0aW9uID0+IGNsZWFudXBGdW5jdGlvbigpKTtcbiAgICB9O1xuICB9LCBbY29tbWl0dGVkVmFsdWVzUmVmLCBlYWdlclZhbHVlc1JlZiwgZ3JvdXBJZCwgbGF5b3V0LCBwYW5lbERhdGFBcnJheSwgc2V0TGF5b3V0XSk7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsKGFycmF5QSwgYXJyYXlCKSB7XG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5QVtpbmRleF0gIT09IGFycmF5QltpbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzS2V5RG93bihldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCI7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcIm1vdXNlXCIpO1xufVxuZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IGV2ZW50LmNsaWVudFggOiBldmVudC5jbGllbnRZO1xuICB9IGVsc2UgaWYgKGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICBjb25zdCBmaXJzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICBhc3NlcnQoZmlyc3RUb3VjaCk7XG4gICAgcmV0dXJuIGlzSG9yaXpvbnRhbCA/IGZpcnN0VG91Y2guc2NyZWVuWCA6IGZpcnN0VG91Y2guc2NyZWVuWTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZlbnQgdHlwZSBcIiR7ZXZlbnQudHlwZX1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSkge1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChkcmFnSGFuZGxlSWQpO1xuICBhc3NlcnQoaGFuZGxlRWxlbWVudCk7XG4gIGNvbnN0IGdyb3VwSWQgPSBoYW5kbGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIik7XG4gIGFzc2VydChncm91cElkKTtcbiAgbGV0IHtcbiAgICBpbml0aWFsQ3Vyc29yUG9zaXRpb25cbiAgfSA9IGluaXRpYWxEcmFnU3RhdGU7XG4gIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KTtcbiAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cEVsZW1lbnQoZ3JvdXBJZCk7XG4gIGFzc2VydChncm91cEVsZW1lbnQpO1xuICBjb25zdCBncm91cFJlY3QgPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGdyb3VwU2l6ZUluUGl4ZWxzID0gaXNIb3Jpem9udGFsID8gZ3JvdXBSZWN0LndpZHRoIDogZ3JvdXBSZWN0LmhlaWdodDtcbiAgY29uc3Qgb2Zmc2V0UGl4ZWxzID0gY3Vyc29yUG9zaXRpb24gLSBpbml0aWFsQ3Vyc29yUG9zaXRpb247XG4gIGNvbnN0IG9mZnNldFBlcmNlbnRhZ2UgPSBvZmZzZXRQaXhlbHMgLyBncm91cFNpemVJblBpeGVscyAqIDEwMDtcbiAgcmV0dXJuIG9mZnNldFBlcmNlbnRhZ2U7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L21vdmVtZW50WFxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGFQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwga2V5Ym9hcmRSZXNpemVCeSkge1xuICBpZiAoaXNLZXlEb3duKGV2ZW50KSkge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGRlbHRhID0gMTAwO1xuICAgIH0gZWxzZSBpZiAoa2V5Ym9hcmRSZXNpemVCeSAhPSBudWxsKSB7XG4gICAgICBkZWx0YSA9IGtleWJvYXJkUmVzaXplQnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhID0gMTA7XG4gICAgfVxuICAgIGxldCBtb3ZlbWVudCA9IDA7XG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogZGVsdGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IC1kZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyBkZWx0YSA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAwIDogLWRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgbW92ZW1lbnQgPSAtMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVtZW50O1xuICB9IGVsc2Uge1xuICAgIGlmIChpbml0aWFsRHJhZ1N0YXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY3VsYXRlRHJhZ09mZnNldFBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBpbml0aWFsRHJhZ1N0YXRlKTtcbiAgfVxufVxuXG4vLyBMYXlvdXQgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWQgaW50byBwZXJjZW50YWdlc1xuZnVuY3Rpb24gY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBsYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApIHtcbiAgbGF5b3V0LmZvckVhY2goKHNpemUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGFzc2VydChwYW5lbERhdGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrcyxcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgaWQ6IHBhbmVsSWRcbiAgICB9ID0gcGFuZWxEYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGVcbiAgICB9ID0gY29uc3RyYWludHM7XG4gICAgY29uc3QgbGFzdE5vdGlmaWVkU2l6ZSA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbcGFuZWxJZF07XG4gICAgaWYgKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBzaXplICE9PSBsYXN0Tm90aWZpZWRTaXplKSB7XG4gICAgICBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwW3BhbmVsSWRdID0gc2l6ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Db2xsYXBzZSxcbiAgICAgICAgb25FeHBhbmQsXG4gICAgICAgIG9uUmVzaXplXG4gICAgICB9ID0gY2FsbGJhY2tzO1xuICAgICAgaWYgKG9uUmVzaXplKSB7XG4gICAgICAgIG9uUmVzaXplKHNpemUsIGxhc3ROb3RpZmllZFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNpYmxlICYmIChvbkNvbGxhcHNlIHx8IG9uRXhwYW5kKSkge1xuICAgICAgICBpZiAob25FeHBhbmQgJiYgKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBsYXN0Tm90aWZpZWRTaXplID09PSBjb2xsYXBzZWRTaXplKSAmJiBzaXplICE9PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgICAgb25FeHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Db2xsYXBzZSAmJiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IGxhc3ROb3RpZmllZFNpemUgIT09IGNvbGxhcHNlZFNpemUpICYmIHNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTGF5b3V0cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoYVtpbmRleF0gIT0gYltpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDEwMCByZXByZXNlbnRpbmdcblxuLy8gdGhlICUgb2YgdGhlIGdyb3VwJ3Mgb3ZlcmFsbCBzcGFjZSB0aGlzIHBhbmVsIHNob3VsZCBvY2N1cHkuXG5mdW5jdGlvbiBjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUoe1xuICBkcmFnU3RhdGUsXG4gIGxheW91dCxcbiAgcGFuZWxEYXRhLFxuICBwYW5lbEluZGV4LFxuICBwcmVjaXNpb24gPSAzXG59KSB7XG4gIGNvbnN0IHNpemUgPSBsYXlvdXRbcGFuZWxJbmRleF07XG4gIGxldCBmbGV4R3JvdztcbiAgaWYgKHBhbmVsRGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICBmbGV4R3JvdyA9IFwiMVwiO1xuICB9IGVsc2UgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgcmVuZGVyIChiZWZvcmUgcGFuZWxzIGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzKVxuICAgIGZsZXhHcm93ID0gXCIxXCI7XG4gIH0gZWxzZSB7XG4gICAgZmxleEdyb3cgPSBzaXplLnRvUHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmbGV4QmFzaXM6IDAsXG4gICAgZmxleEdyb3csXG4gICAgZmxleFNocmluazogMSxcbiAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50XG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBpbnNpZGUgb2YgYSBwYW5lbCBkdXJpbmcgcmVzaXplXG4gICAgLy8gVGhpcyBhdm9pZCBlZGdlIGNhc2VzIGxpa2UgbmVzdGVkIGlmcmFtZXNcbiAgICBwb2ludGVyRXZlbnRzOiBkcmFnU3RhdGUgIT09IG51bGwgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5sZXQgY3VycmVudFN0YXRlID0gbnVsbDtcbmxldCBlbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgcmV0dXJuIFwiZXctcmVzaXplXCI7XG4gICAgY2FzZSBcImhvcml6b250YWwtbWF4XCI6XG4gICAgICByZXR1cm4gXCJ3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJob3Jpem9udGFsLW1pblwiOlxuICAgICAgcmV0dXJuIFwiZS1yZXNpemVcIjtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcIm5zLXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbC1tYXhcIjpcbiAgICAgIHJldHVybiBcIm4tcmVzaXplXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsLW1pblwiOlxuICAgICAgcmV0dXJuIFwicy1yZXNpemVcIjtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpIHtcbiAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIGN1cnJlbnRTdGF0ZSA9IG51bGw7XG4gICAgZWxlbWVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCBzdHlsZSA9IGdldEN1cnNvclN0eWxlKHN0YXRlKTtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgKntjdXJzb3I6ICR7c3R5bGV9IWltcG9ydGFudDt9YDtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIGR1cmF0aW9uTXMgPSAxMCkge1xuICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgbGV0IGNhbGxhYmxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9LCBkdXJhdGlvbk1zKTtcbiAgfTtcbiAgcmV0dXJuIGNhbGxhYmxlO1xufVxuXG4vLyBQYW5lbEdyb3VwIG1pZ2h0IGJlIHJlbmRlcmluZyBpbiBhIHNlcnZlci1zaWRlIGVudmlyb25tZW50IHdoZXJlIGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlXG4vLyBvciBvbiBhIGJyb3dzZXIgd2l0aCBjb29raWVzL3N0b3JhZ2UgZGlzYWJsZWQuXG4vLyBJbiBlaXRoZXIgY2FzZSwgdGhpcyBmdW5jdGlvbiBhdm9pZHMgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSB1bnRpbCBuZWVkZWQsXG4vLyBhbmQgYXZvaWRzIHRocm93aW5nIHVzZXItdmlzaWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBCeXBhc3MgdGhpcyBjaGVjayBmb3IgZnV0dXJlIGNhbGxzXG4gICAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2NhbFN0b3JhZ2Ugbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSAoKSA9PiBudWxsO1xuICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9ICgpID0+IHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCkge1xuICByZXR1cm4gYHJlYWN0LXJlc2l6YWJsZS1wYW5lbHM6JHthdXRvU2F2ZUlkfWA7XG59XG5cbi8vIE5vdGUgdGhhdCBQYW5lbCBpZHMgbWlnaHQgYmUgdXNlci1wcm92aWRlZCAoc3RhYmxlKSBvciB1c2VJZCBnZW5lcmF0ZWQgKG5vbi1kZXRlcm1pbmlzdGljKVxuLy8gc28gdGhleSBzaG91bGQgbm90IGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc2VyaWFsaXphdGlvbiBrZXkuXG4vLyBVc2luZyB0aGUgbWluL21heCBzaXplIGF0dHJpYnV0ZXMgc2hvdWxkIHdvcmsgd2VsbCBlbm91Z2ggYXMgYSBiYWNrdXAuXG4vLyBQcmUtc29ydGluZyBieSBtaW5TaXplIGFsbG93cyByZW1lbWJlcmluZyBsYXlvdXRzIGV2ZW4gaWYgcGFuZWxzIGFyZSByZS1vcmRlcmVkL2RyYWdnZWQuXG5mdW5jdGlvbiBnZXRQYW5lbEtleShwYW5lbHMpIHtcbiAgcmV0dXJuIHBhbmVscy5tYXAocGFuZWwgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgaWQsXG4gICAgICBpZElzRnJvbVByb3BzLFxuICAgICAgb3JkZXJcbiAgICB9ID0gcGFuZWw7XG4gICAgaWYgKGlkSXNGcm9tUHJvcHMpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yZGVyID8gYCR7b3JkZXJ9OiR7SlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpfWAgOiBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cyk7XG4gICAgfVxuICB9KS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpLmpvaW4oXCIsXCIpO1xufVxuZnVuY3Rpb24gbG9hZFNlcmlhbGl6ZWRQYW5lbEdyb3VwU3RhdGUoYXV0b1NhdmVJZCwgc3RvcmFnZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhbmVsR3JvdXBLZXkgPSBnZXRQYW5lbEdyb3VwS2V5KGF1dG9TYXZlSWQpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzdG9yYWdlLmdldEl0ZW0ocGFuZWxHcm91cEtleSk7XG4gICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gXCJvYmplY3RcIiAmJiBwYXJzZWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2F2ZVBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBwYW5lbHMsIHBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSwgc2l6ZXMsIHN0b3JhZ2UpIHtcbiAgdmFyIF9sb2FkU2VyaWFsaXplZFBhbmVsRzI7XG4gIGNvbnN0IHBhbmVsR3JvdXBLZXkgPSBnZXRQYW5lbEdyb3VwS2V5KGF1dG9TYXZlSWQpO1xuICBjb25zdCBwYW5lbEtleSA9IGdldFBhbmVsS2V5KHBhbmVscyk7XG4gIGNvbnN0IHN0YXRlID0gKF9sb2FkU2VyaWFsaXplZFBhbmVsRzIgPSBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSkgIT09IG51bGwgJiYgX2xvYWRTZXJpYWxpemVkUGFuZWxHMiAhPT0gdm9pZCAwID8gX2xvYWRTZXJpYWxpemVkUGFuZWxHMiA6IHt9O1xuICBzdGF0ZVtwYW5lbEtleV0gPSB7XG4gICAgZXhwYW5kVG9TaXplczogT2JqZWN0LmZyb21FbnRyaWVzKHBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZS5lbnRyaWVzKCkpLFxuICAgIGxheW91dDogc2l6ZXNcbiAgfTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlLnNldEl0ZW0ocGFuZWxHcm91cEtleSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhbmVsQ29uc3RyYWludHMoe1xuICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gIHBhbmVsSWQsXG4gIHBhbmVsSW5kZXhcbn0pIHtcbiAge1xuICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtwYW5lbEluZGV4XTtcbiAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIG1heFNpemUgPSAxMDAsXG4gICAgICBtaW5TaXplID0gMFxuICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICAgIGlmIChtaW5TaXplID4gbWF4U2l6ZSkge1xuICAgICAgd2FybmluZ3MucHVzaChgbWluIHNpemUgKCR7bWluU2l6ZX0lKSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggc2l6ZSAoJHttYXhTaXplfSUpYCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPCAwKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFNpemUgPCBtaW5TaXplKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gbWluIHNpemVcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPiAxMDApIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMDBcIik7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBzaXplXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGFwc2VkU2l6ZSA+IG1pblNpemUpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goXCJjb2xsYXBzZWQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtaW4gc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYW5lbElkICE9IG51bGwgPyBgUGFuZWwgXCIke3BhbmVsSWR9XCJgIDogXCJQYW5lbFwiO1xuICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IGhhcyBhbiBpbnZhbGlkIGNvbmZpZ3VyYXRpb246XFxuXFxuJHt3YXJuaW5ncy5qb2luKFwiXFxuXCIpfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICBwYW5lbENvbnN0cmFpbnRzXG59KSB7XG4gIGNvbnN0IG5leHRMYXlvdXQgPSBbLi4ucHJldkxheW91dF07XG4gIGNvbnN0IG5leHRMYXlvdXRUb3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgoYWNjdW11bGF0ZWQsIGN1cnJlbnQpID0+IGFjY3VtdWxhdGVkICsgY3VycmVudCwgMCk7XG5cbiAgLy8gVmFsaWRhdGUgbGF5b3V0IGV4cGVjdGF0aW9uc1xuICBpZiAobmV4dExheW91dC5sZW5ndGggIT09IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoYEludmFsaWQgJHtwYW5lbENvbnN0cmFpbnRzLmxlbmd0aH0gcGFuZWwgbGF5b3V0OiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfWApO1xuICB9IGVsc2UgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChuZXh0TGF5b3V0VG90YWxTaXplLCAxMDApKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgaWRlYWwgc28gd2Ugc2hvdWxkIHdhcm4gYWJvdXQgaXQsIGJ1dCBpdCBtYXkgYmUgcmVjb3ZlcmFibGUgaW4gc29tZSBjYXNlc1xuICAgIC8vIChlc3BlY2lhbGx5IGlmIHRoZSBhbW91bnQgaXMgc21hbGwpXG4gICAge1xuICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBJbnZhbGlkIGxheW91dCB0b3RhbCBzaXplOiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfS4gTGF5b3V0IG5vcm1hbGl6YXRpb24gd2lsbCBiZSBhcHBsaWVkLmApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwpO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSAxMDAgLyBuZXh0TGF5b3V0VG90YWxTaXplICogdW5zYWZlU2l6ZTtcbiAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgfVxuICB9XG4gIGxldCByZW1haW5pbmdTaXplID0gMDtcblxuICAvLyBGaXJzdCBwYXNzOiBWYWxpZGF0ZSB0aGUgcHJvcG9zZWQgbGF5b3V0IGdpdmVuIGVhY2ggcGFuZWwncyBjb25zdHJhaW50c1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCB1bnNhZmVTaXplID0gbmV4dExheW91dFtpbmRleF07XG4gICAgYXNzZXJ0KHVuc2FmZVNpemUgIT0gbnVsbCk7XG4gICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICBwYW5lbENvbnN0cmFpbnRzLFxuICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgfSk7XG4gICAgaWYgKHVuc2FmZVNpemUgIT0gc2FmZVNpemUpIHtcbiAgICAgIHJlbWFpbmluZ1NpemUgKz0gdW5zYWZlU2l6ZSAtIHNhZmVTaXplO1xuICAgICAgbmV4dExheW91dFtpbmRleF0gPSBzYWZlU2l6ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhZGRpdGlvbmFsLCBsZWZ0IG92ZXIgc3BhY2UsIGFzc2lnbiBpdCB0byBhbnkgcGFuZWwocykgdGhhdCBwZXJtaXRzIGl0XG4gIC8vIChJdCdzIG5vdCB3b3J0aCB0YWtpbmcgbXVsdGlwbGUgYWRkaXRpb25hbCBwYXNzZXMgdG8gZXZlbmx5IGRpc3RyaWJ1dGUpXG4gIGlmICghZnV6enlOdW1iZXJzRXF1YWwocmVtYWluaW5nU2l6ZSwgMCkpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHByZXZTaXplID0gbmV4dExheW91dFtpbmRleF07XG4gICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCk7XG4gICAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgKyByZW1haW5pbmdTaXplO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2U2l6ZSAhPT0gc2FmZVNpemUpIHtcbiAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBzYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuXG4gICAgICAgIC8vIE9uY2Ugd2UndmUgdXNlZCB1cCB0aGUgcmVtYWluZGVyLCBiYWlsXG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChyZW1haW5pbmdTaXplLCAwKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0TGF5b3V0O1xufVxuXG5jb25zdCBMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMID0gMTAwO1xuY29uc3QgZGVmYXVsdFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IG5hbWUgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgcmV0dXJuIGRlZmF1bHRTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gIH0sXG4gIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgZGVmYXVsdFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5jb25zdCBkZWJvdW5jZU1hcCA9IHt9O1xuZnVuY3Rpb24gUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYoe1xuICBhdXRvU2F2ZUlkID0gbnVsbCxcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlyZWN0aW9uLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG9uTGF5b3V0ID0gbnVsbCxcbiAga2V5Ym9hcmRSZXNpemVCeSA9IG51bGwsXG4gIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzLFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBncm91cElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBbZHJhZ1N0YXRlLCBzZXREcmFnU3RhdGVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtsYXlvdXQsIHNldExheW91dF0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZiA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICBjb25zdCBwcmV2RGVsdGFSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGNvbW1pdHRlZFZhbHVlc1JlZiA9IHVzZVJlZih7XG4gICAgYXV0b1NhdmVJZCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZHJhZ1N0YXRlLFxuICAgIGlkOiBncm91cElkLFxuICAgIGtleWJvYXJkUmVzaXplQnksXG4gICAgb25MYXlvdXQsXG4gICAgc3RvcmFnZVxuICB9KTtcbiAgY29uc3QgZWFnZXJWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGxheW91dCxcbiAgICBwYW5lbERhdGFBcnJheTogW10sXG4gICAgcGFuZWxEYXRhQXJyYXlDaGFuZ2VkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgZGV2V2FybmluZ3NSZWYgPSB1c2VSZWYoe1xuICAgIGRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nOiBmYWxzZSxcbiAgICBkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZzogZmFsc2UsXG4gICAgcHJldlBhbmVsSWRzOiBbXVxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgZ2V0SWQ6ICgpID0+IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LmlkLFxuICAgIGdldExheW91dDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9LFxuICAgIHNldExheW91dDogdW5zYWZlTGF5b3V0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25MYXlvdXRcbiAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICBwYW5lbERhdGFBcnJheVxuICAgICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzYWZlTGF5b3V0ID0gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgICAgICAgbGF5b3V0OiB1bnNhZmVMYXlvdXQsXG4gICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKVxuICAgICAgfSk7XG4gICAgICBpZiAoIWFyZUVxdWFsKHByZXZMYXlvdXQsIHNhZmVMYXlvdXQpKSB7XG4gICAgICAgIHNldExheW91dChzYWZlTGF5b3V0KTtcbiAgICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBzYWZlTGF5b3V0O1xuICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICBvbkxheW91dChzYWZlTGF5b3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIHNhZmVMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW10pO1xuICB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICAgIGVhZ2VyVmFsdWVzUmVmLFxuICAgIGdyb3VwSWQsXG4gICAgbGF5b3V0LFxuICAgIHBhbmVsRGF0YUFycmF5OiBlYWdlclZhbHVlc1JlZi5jdXJyZW50LnBhbmVsRGF0YUFycmF5LFxuICAgIHNldExheW91dFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gSWYgdGhpcyBwYW5lbCBoYXMgYmVlbiBjb25maWd1cmVkIHRvIHBlcnNpc3Qgc2l6aW5nIGluZm9ybWF0aW9uLCBzYXZlIHNpemVzIHRvIGxvY2FsIHN0b3JhZ2UuXG4gICAgaWYgKGF1dG9TYXZlSWQpIHtcbiAgICAgIGlmIChsYXlvdXQubGVuZ3RoID09PSAwIHx8IGxheW91dC5sZW5ndGggIT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVib3VuY2VkU2F2ZSA9IGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdO1xuXG4gICAgICAvLyBMaW1pdCB0aGUgZnJlcXVlbmN5IG9mIGxvY2FsU3RvcmFnZSB1cGRhdGVzLlxuICAgICAgaWYgKGRlYm91bmNlZFNhdmUgPT0gbnVsbCkge1xuICAgICAgICBkZWJvdW5jZWRTYXZlID0gZGVib3VuY2Uoc2F2ZVBhbmVsR3JvdXBTdGF0ZSwgTE9DQUxfU1RPUkFHRV9ERUJPVU5DRV9JTlRFUlZBTCk7XG4gICAgICAgIGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdID0gZGVib3VuY2VkU2F2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xvbmUgbXV0YWJsZSBkYXRhIGJlZm9yZSBwYXNzaW5nIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24sXG4gICAgICAvLyBlbHNlIHdlIHJ1biB0aGUgcmlzayBvZiBzYXZpbmcgYW4gaW5jb3JyZWN0IGNvbWJpbmF0aW9uIG9mIG11dGFibGUgYW5kIGltbXV0YWJsZSB2YWx1ZXMgdG8gc3RhdGUuXG4gICAgICBjb25zdCBjbG9uZWRQYW5lbERhdGFBcnJheSA9IFsuLi5wYW5lbERhdGFBcnJheV07XG4gICAgICBjb25zdCBjbG9uZWRQYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UgPSBuZXcgTWFwKHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmLmN1cnJlbnQpO1xuICAgICAgZGVib3VuY2VkU2F2ZShhdXRvU2F2ZUlkLCBjbG9uZWRQYW5lbERhdGFBcnJheSwgY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLCBsYXlvdXQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfSwgW2F1dG9TYXZlSWQsIGxheW91dCwgc3RvcmFnZV0pO1xuXG4gIC8vIERFViB3YXJuaW5nc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZyxcbiAgICAgICAgZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmcsXG4gICAgICAgIHByZXZQYW5lbElkc1xuICAgICAgfSA9IGRldldhcm5pbmdzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhbmVsSWRzID0gcGFuZWxEYXRhQXJyYXkubWFwKCh7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSkgPT4gaWQpO1xuICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LnByZXZQYW5lbElkcyA9IHBhbmVsSWRzO1xuICAgICAgICBjb25zdCBwYW5lbHNIYXZlQ2hhbmdlZCA9IHByZXZQYW5lbElkcy5sZW5ndGggPiAwICYmICFhcmVFcXVhbChwcmV2UGFuZWxJZHMsIHBhbmVsSWRzKTtcbiAgICAgICAgaWYgKHBhbmVsc0hhdmVDaGFuZ2VkKSB7XG4gICAgICAgICAgaWYgKHBhbmVsRGF0YUFycmF5LmZpbmQoKHtcbiAgICAgICAgICAgIGlkSXNGcm9tUHJvcHMsXG4gICAgICAgICAgICBvcmRlclxuICAgICAgICAgIH0pID0+ICFpZElzRnJvbVByb3BzIHx8IG9yZGVyID09IG51bGwpKSB7XG4gICAgICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgaWQgYW5kIG9yZGVyIHByb3BzIHJlY29tbWVuZGVkIHdoZW4gcGFuZWxzIGFyZSBkeW5hbWljYWxseSByZW5kZXJlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZykge1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgICAgICBmb3IgKGxldCBwYW5lbEluZGV4ID0gMDsgcGFuZWxJbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBwYW5lbEluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbERhdGFBcnJheVtwYW5lbEluZGV4XTtcbiAgICAgICAgICBhc3NlcnQocGFuZWxEYXRhKTtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVQYW5lbENvbnN0cmFpbnRzKHtcbiAgICAgICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgICAgICBwYW5lbElkOiBwYW5lbERhdGEuaWQsXG4gICAgICAgICAgICBwYW5lbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBjb2xsYXBzZVBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmIChwYW5lbERhdGEuY29uc3RyYWludHMuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgIHBhbmVsU2l6ZSxcbiAgICAgICAgcGl2b3RJbmRpY2VzXG4gICAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIHByZXZMYXlvdXQpO1xuICAgICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsKTtcbiAgICAgIGlmIChwYW5lbFNpemUgIT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgLy8gU3RvcmUgc2l6ZSBiZWZvcmUgY29sbGFwc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHNpemUgdGhhdCBnZXRzIHJlc3RvcmVkIGlmIHRoZSBleHBhbmQoKSBBUEkgaXMgdXNlZC5cbiAgICAgICAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYuY3VycmVudC5zZXQocGFuZWxEYXRhLmlkLCBwYW5lbFNpemUpO1xuICAgICAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IHBhbmVsU2l6ZSAtIGNvbGxhcHNlZFNpemUgOiBjb2xsYXBzZWRTaXplIC0gcGFuZWxTaXplO1xuICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgICBwaXZvdEluZGljZXMsXG4gICAgICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGV4cGFuZFBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmIChwYW5lbERhdGEuY29uc3RyYWludHMuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgIHBhbmVsU2l6ZSxcbiAgICAgICAgbWluU2l6ZSA9IDAsXG4gICAgICAgIHBpdm90SW5kaWNlc1xuICAgICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICAgIGlmIChwYW5lbFNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGlzIHBhbmVsIHRvIHRoZSBzaXplIGl0IHdhcyBiZWZvcmUgaXQgd2FzIGNvbGxhcHNlZCwgaWYgcG9zc2libGUuXG4gICAgICAgIGNvbnN0IHByZXZQYW5lbFNpemUgPSBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50LmdldChwYW5lbERhdGEuaWQpO1xuICAgICAgICBjb25zdCBiYXNlU2l6ZSA9IHByZXZQYW5lbFNpemUgIT0gbnVsbCAmJiBwcmV2UGFuZWxTaXplID49IG1pblNpemUgPyBwcmV2UGFuZWxTaXplIDogbWluU2l6ZTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFuZWwgPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkgPT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSBiYXNlU2l6ZSA6IGJhc2VTaXplIC0gcGFuZWxTaXplO1xuICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgICBwaXZvdEluZGljZXMsXG4gICAgICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGdldFBhbmVsU2l6ZSA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsKTtcbiAgICByZXR1cm4gcGFuZWxTaXplO1xuICB9LCBbXSk7XG5cbiAgLy8gVGhpcyBBUEkgc2hvdWxkIG5ldmVyIHJlYWQgZnJvbSBjb21taXR0ZWRWYWx1ZXNSZWZcbiAgY29uc3QgZ2V0UGFuZWxTdHlsZSA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbEluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICAgIHJldHVybiBjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUoe1xuICAgICAgZHJhZ1N0YXRlLFxuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhOiBwYW5lbERhdGFBcnJheSxcbiAgICAgIHBhbmVsSW5kZXhcbiAgICB9KTtcbiAgfSwgW2RyYWdTdGF0ZSwgbGF5b3V0XSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBpc1BhbmVsQ29sbGFwc2VkID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgcmV0dXJuIGNvbGxhcHNpYmxlID09PSB0cnVlICYmIHBhbmVsU2l6ZSA9PT0gY29sbGFwc2VkU2l6ZTtcbiAgfSwgW10pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgaXNQYW5lbEV4cGFuZGVkID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsKTtcbiAgICByZXR1cm4gIWNvbGxhcHNpYmxlIHx8IHBhbmVsU2l6ZSA+IGNvbGxhcHNlZFNpemU7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBwYW5lbERhdGFBcnJheS5wdXNoKHBhbmVsRGF0YSk7XG4gICAgcGFuZWxEYXRhQXJyYXkuc29ydCgocGFuZWxBLCBwYW5lbEIpID0+IHtcbiAgICAgIGNvbnN0IG9yZGVyQSA9IHBhbmVsQS5vcmRlcjtcbiAgICAgIGNvbnN0IG9yZGVyQiA9IHBhbmVsQi5vcmRlcjtcbiAgICAgIGlmIChvcmRlckEgPT0gbnVsbCAmJiBvcmRlckIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAob3JkZXJBID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChvcmRlckIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcmRlckEgLSBvcmRlckI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5wYW5lbERhdGFBcnJheUNoYW5nZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUmVzaXplSGFuZGxlID0gdXNlQ2FsbGJhY2soZHJhZ0hhbmRsZUlkID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVzaXplSGFuZGxlcihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBkcmFnU3RhdGUsXG4gICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICBrZXlib2FyZFJlc2l6ZUJ5LFxuICAgICAgICBvbkxheW91dFxuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhbExheW91dFxuICAgICAgfSA9IGRyYWdTdGF0ZSAhPT0gbnVsbCAmJiBkcmFnU3RhdGUgIT09IHZvaWQgMCA/IGRyYWdTdGF0ZSA6IHt9O1xuICAgICAgY29uc3QgcGl2b3RJbmRpY2VzID0gZGV0ZXJtaW5lUGl2b3RJbmRpY2VzKGdyb3VwSWQsIGRyYWdIYW5kbGVJZCk7XG4gICAgICBsZXQgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBkcmFnU3RhdGUsIGtleWJvYXJkUmVzaXplQnkpO1xuICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydCBSVEwgbGF5b3V0c1xuICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgICAgIGlmIChkb2N1bWVudC5kaXIgPT09IFwicnRsXCIgJiYgaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGxheW91dDogaW5pdGlhbExheW91dCAhPT0gbnVsbCAmJiBpbml0aWFsTGF5b3V0ICE9PSB2b2lkIDAgPyBpbml0aWFsTGF5b3V0IDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgICB0cmlnZ2VyOiBpc0tleURvd24oZXZlbnQpID8gXCJrZXlib2FyZFwiIDogXCJtb3VzZS1vci10b3VjaFwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxheW91dENoYW5nZWQgPSAhY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCk7XG5cbiAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBjdXJzb3IgZm9yIGxheW91dCBjaGFuZ2VzIHRyaWdnZXJlZCBieSB0b3VjaC9tb3VzZSBldmVudHMgKG5vdCBrZXlib2FyZClcbiAgICAgIC8vIFVwZGF0ZSB0aGUgY3Vyc29yIGV2ZW4gaWYgdGhlIGxheW91dCBoYXNuJ3QgY2hhbmdlZCAod2UgbWF5IG5lZWQgdG8gc2hvdyBhbiBpbnZhbGlkIGN1cnNvciBzdGF0ZSlcbiAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpIHx8IGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgLy8gV2F0Y2ggZm9yIG11bHRpcGxlIHN1YnNlcXVlbnQgZGVsdGFzOyB0aGlzIG1pZ2h0IG9jY3VyIGZvciB0aW55IGN1cnNvciBtb3ZlbWVudHMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgUGFuZWwgc2l6ZXMgbWlnaHQgbm90IGNoYW5nZeKAk1xuICAgICAgICAvLyBidXQgdXBkYXRpbmcgY3Vyc29yIGluIHRoaXMgc2NlbmFyaW8gd291bGQgY2F1c2UgYSBmbGlja2VyLlxuICAgICAgICBpZiAocHJldkRlbHRhUmVmLmN1cnJlbnQgIT0gZGVsdGEpIHtcbiAgICAgICAgICBwcmV2RGVsdGFSZWYuY3VycmVudCA9IGRlbHRhO1xuICAgICAgICAgIGlmICghbGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaGFzIG1vdmVkIHRvbyBmYXIgdG8gcmVzaXplIHRoZSBwYW5lbCBhbnkgZnVydGhlcixcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY3Vyc29yIHN0eWxlIGZvciBhIHZpc3VhbCBjbHVlLlxuICAgICAgICAgICAgLy8gVGhpcyBtaW1pY3MgVlMgQ29kZSBiZWhhdmlvci5cblxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShkZWx0YSA8IDAgPyBcImhvcml6b250YWwtbWluXCIgOiBcImhvcml6b250YWwtbWF4XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoZGVsdGEgPCAwID8gXCJ2ZXJ0aWNhbC1taW5cIiA6IFwidmVydGljYWwtbWF4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgY3Vyc29yIHN0eWxlIHRvIHRoZSB0aGUgbm9ybWFsIHJlc2l6ZSBjdXJzb3IuXG4gICAgICAgICAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShpc0hvcml6b250YWwgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBuZXh0TGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IHJlc2l6ZVBhbmVsID0gdXNlQ2FsbGJhY2soKHBhbmVsRGF0YSwgdW5zYWZlUGFuZWxTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25MYXlvdXRcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzQXJyYXkgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxTaXplLFxuICAgICAgcGl2b3RJbmRpY2VzXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwpO1xuICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSB1bnNhZmVQYW5lbFNpemUgOiB1bnNhZmVQYW5lbFNpemUgLSBwYW5lbFNpemU7XG4gICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgZGVsdGEsXG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICBwaXZvdEluZGljZXMsXG4gICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICB9KTtcbiAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICB9XG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoZHJhZ0hhbmRsZUlkLCBldmVudCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvblxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXRcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChkcmFnSGFuZGxlSWQpO1xuICAgIGFzc2VydChoYW5kbGVFbGVtZW50KTtcbiAgICBjb25zdCBpbml0aWFsQ3Vyc29yUG9zaXRpb24gPSBnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uKGRpcmVjdGlvbiwgZXZlbnQpO1xuICAgIHNldERyYWdTdGF0ZSh7XG4gICAgICBkcmFnSGFuZGxlSWQsXG4gICAgICBkcmFnSGFuZGxlUmVjdDogaGFuZGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGluaXRpYWxDdXJzb3JQb3NpdGlvbixcbiAgICAgIGluaXRpYWxMYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHN0b3BEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXNldEdsb2JhbEN1cnNvclN0eWxlKCk7XG4gICAgc2V0RHJhZ1N0YXRlKG51bGwpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcGFuZWxEYXRhQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gVFJJQ0tZXG4gICAgICAvLyBXaGVuIGEgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCwgd2Ugc2hvdWxkIGRlbGV0ZSB0aGUgbW9zdCByZWNlbnQgcHJldi1zaXplIGVudHJ5IGZvciBpdC5cbiAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gYSBjb25kaXRpb25hbGx5IHJlbmRlcmVkIHBhbmVsIG1pZ2h0IG5vdCBjYWxsIG9uUmVzaXplIHdoZW4gaXQncyByZS1tb3VudGVkLlxuICAgICAgLy8gU3RyaWN0IGVmZmVjdHMgbW9kZSBtYWtlcyB0aGlzIHRyaWNreSB0aG91Z2ggYmVjYXVzZSBhbGwgcGFuZWxzIHdpbGwgYmUgcmVnaXN0ZXJlZCwgdW5yZWdpc3RlcmVkLCB0aGVuIHJlLXJlZ2lzdGVyZWQgb24gbW91bnQuXG4gICAgICBkZWxldGUgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50W3BhbmVsRGF0YS5pZF07XG4gICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LnBhbmVsRGF0YUFycmF5Q2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZHJhZ1N0YXRlLFxuICAgIGV4cGFuZFBhbmVsLFxuICAgIGdldFBhbmVsU2l6ZSxcbiAgICBnZXRQYW5lbFN0eWxlLFxuICAgIGdyb3VwSWQsXG4gICAgaXNQYW5lbENvbGxhcHNlZCxcbiAgICBpc1BhbmVsRXhwYW5kZWQsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICByZXNpemVQYW5lbCxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZyxcbiAgICB1bnJlZ2lzdGVyUGFuZWxcbiAgfSksIFtjb2xsYXBzZVBhbmVsLCBkcmFnU3RhdGUsIGRpcmVjdGlvbiwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgZ2V0UGFuZWxTdHlsZSwgZ3JvdXBJZCwgaXNQYW5lbENvbGxhcHNlZCwgaXNQYW5lbEV4cGFuZGVkLCByZWdpc3RlclBhbmVsLCByZWdpc3RlclJlc2l6ZUhhbmRsZSwgcmVzaXplUGFuZWwsIHN0YXJ0RHJhZ2dpbmcsIHN0b3BEcmFnZ2luZywgdW5yZWdpc3RlclBhbmVsXSk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcInJvd1wiIDogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIlxuICB9O1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXBcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZFxuICB9KSk7XG59XG5jb25zdCBQYW5lbEdyb3VwID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwXCI7XG5QYW5lbEdyb3VwLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsR3JvdXApXCI7XG5mdW5jdGlvbiBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkge1xuICByZXR1cm4gcGFuZWxEYXRhQXJyYXkuZmluZEluZGV4KHByZXZQYW5lbERhdGEgPT4gcHJldlBhbmVsRGF0YSA9PT0gcGFuZWxEYXRhIHx8IHByZXZQYW5lbERhdGEuaWQgPT09IHBhbmVsRGF0YS5pZCk7XG59XG5mdW5jdGlvbiBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KSB7XG4gIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgY29uc3QgcGFuZWxJbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtwYW5lbEluZGV4XTtcbiAgY29uc3QgaXNMYXN0UGFuZWwgPSBwYW5lbEluZGV4ID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICBjb25zdCBwaXZvdEluZGljZXMgPSBpc0xhc3RQYW5lbCA/IFtwYW5lbEluZGV4IC0gMSwgcGFuZWxJbmRleF0gOiBbcGFuZWxJbmRleCwgcGFuZWxJbmRleCArIDFdO1xuICBjb25zdCBwYW5lbFNpemUgPSBsYXlvdXRbcGFuZWxJbmRleF07XG4gIHJldHVybiB7XG4gICAgLi4ucGFuZWxDb25zdHJhaW50cyxcbiAgICBwYW5lbFNpemUsXG4gICAgcGl2b3RJbmRpY2VzXG4gIH07XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvd2luZG93c3BsaXR0ZXIvXG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgZGlzYWJsZWQsXG4gIGhhbmRsZUlkLFxuICByZXNpemVIYW5kbGVyXG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChoYW5kbGVJZCk7XG4gICAgaWYgKGhhbmRsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkY2XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBoYW5kbGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIik7XG4gICAgICAgICAgICBhc3NlcnQoZ3JvdXBJZCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4KGdyb3VwSWQsIGhhbmRsZUlkKTtcbiAgICAgICAgICAgIGFzc2VydChpbmRleCAhPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBldmVudC5zaGlmdEtleSA/IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGhhbmRsZXMubGVuZ3RoIC0gMSA6IGluZGV4ICsgMSA8IGhhbmRsZXMubGVuZ3RoID8gaW5kZXggKyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGUgPSBoYW5kbGVzW25leHRJbmRleF07XG4gICAgICAgICAgICBuZXh0SGFuZGxlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGhhbmRsZUlkLCByZXNpemVIYW5kbGVyXSk7XG59XG5cbmZ1bmN0aW9uIFBhbmVsUmVzaXplSGFuZGxlKHtcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIGlkOiBpZEZyb21Qcm9wcyxcbiAgb25EcmFnZ2luZyxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhYkluZGV4ID0gMCxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZGl2RWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcblxuICAvLyBVc2UgYSByZWYgdG8gZ3VhcmQgYWdhaW5zdCB1c2VycyBwYXNzaW5nIGlubGluZSBwcm9wc1xuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgIG9uRHJhZ2dpbmdcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25EcmFnZ2luZyA9IG9uRHJhZ2dpbmc7XG4gIH0pO1xuICBjb25zdCBwYW5lbEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAocGFuZWxHcm91cENvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWxSZXNpemVIYW5kbGUgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpcmVjdGlvbixcbiAgICBkcmFnU3RhdGUsXG4gICAgZ3JvdXBJZCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZ1xuICB9ID0gcGFuZWxHcm91cENvbnRleHQ7XG4gIGNvbnN0IHJlc2l6ZUhhbmRsZUlkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBpc0RyYWdnaW5nID0gKGRyYWdTdGF0ZSA9PT0gbnVsbCB8fCBkcmFnU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdTdGF0ZS5kcmFnSGFuZGxlSWQpID09PSByZXNpemVIYW5kbGVJZDtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Jlc2l6ZUhhbmRsZXIsIHNldFJlc2l6ZUhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHN0b3BEcmFnZ2luZ0FuZEJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gQ2xpY2tpbmcgb24gdGhlIGRyYWcgaGFuZGxlIHNob3VsZG4ndCBsZWF2ZSBpdCBmb2N1c2VkO1xuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhlIFBhbmVsR3JvdXAgdG8gdGhpbmsgaXQgd2FzIHN0aWxsIGFjdGl2ZS5cbiAgICBjb25zdCBkaXZFbGVtZW50ID0gZGl2RWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGFzc2VydChkaXZFbGVtZW50KTtcbiAgICBkaXZFbGVtZW50LmJsdXIoKTtcbiAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdnaW5nXG4gICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICBvbkRyYWdnaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtzdG9wRHJhZ2dpbmddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSByZWdpc3RlclJlc2l6ZUhhbmRsZShyZXNpemVIYW5kbGVJZCk7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKCgpID0+IHJlc2l6ZUhhbmRsZXIpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCByZXNpemVIYW5kbGVJZCwgcmVnaXN0ZXJSZXNpemVIYW5kbGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsIHx8ICFpc0RyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gZXZlbnQgPT4ge1xuICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBkaXZFbGVtZW50ID0gZGl2RWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGFzc2VydChkaXZFbGVtZW50KTtcbiAgICBjb25zdCB0YXJnZXREb2N1bWVudCA9IGRpdkVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICB0YXJnZXREb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgfTtcbiAgfSwgW2RpcmVjdGlvbiwgZGlzYWJsZWQsIGlzRHJhZ2dpbmcsIHJlc2l6ZUhhbmRsZXIsIHN0b3BEcmFnZ2luZ0FuZEJsdXJdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICAgIGRpc2FibGVkLFxuICAgIGhhbmRsZUlkOiByZXNpemVIYW5kbGVJZCxcbiAgICByZXNpemVIYW5kbGVyXG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBjdXJzb3I6IGdldEN1cnNvclN0eWxlKGRpcmVjdGlvbiksXG4gICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIG9uQmx1cjogKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSxcbiAgICBvbkZvY3VzOiAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSksXG4gICAgb25Nb3VzZURvd246IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgYXNzZXJ0KGNhbGxiYWNrcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Nb3VzZVVwOiBzdG9wRHJhZ2dpbmdBbmRCbHVyLFxuICAgIG9uVG91Y2hDYW5jZWw6IHN0b3BEcmFnZ2luZ0FuZEJsdXIsXG4gICAgb25Ub3VjaEVuZDogc3RvcERyYWdnaW5nQW5kQmx1cixcbiAgICBvblRvdWNoU3RhcnQ6IGV2ZW50ID0+IHtcbiAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgYXNzZXJ0KGNhbGxiYWNrcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3M7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVmOiBkaXZFbGVtZW50UmVmLFxuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHRhYkluZGV4LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZVwiOiBcIlwiLFxuICAgIFwiZGF0YS1yZXNpemUtaGFuZGxlLWFjdGl2ZVwiOiBpc0RyYWdnaW5nID8gXCJwb2ludGVyXCIgOiBpc0ZvY3VzZWQgPyBcImtleWJvYXJkXCIgOiB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtZW5hYmxlZFwiOiAhZGlzYWJsZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIjogcmVzaXplSGFuZGxlSWRcbiAgfSk7XG59XG5QYW5lbFJlc2l6ZUhhbmRsZS5kaXNwbGF5TmFtZSA9IFwiUGFuZWxSZXNpemVIYW5kbGVcIjtcblxuZXhwb3J0IHsgUGFuZWwsIFBhbmVsR3JvdXAsIFBhbmVsUmVzaXplSGFuZGxlLCBhc3NlcnQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUmVmIiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VJZCIsInRvU3RyaW5nIiwiUGFuZWxHcm91cENvbnRleHQiLCJkaXNwbGF5TmFtZSIsIndyYXBwZWRVc2VJZCIsImNvdW50ZXIiLCJ1c2VVbmlxdWVJZCIsImlkRnJvbVBhcmFtcyIsImlkRnJvbVVzZUlkIiwiaWRSZWYiLCJjdXJyZW50IiwiUGFuZWxXaXRoRm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJjbGFzc05hbWVGcm9tUHJvcHMiLCJjb2xsYXBzZWRTaXplIiwiY29sbGFwc2libGUiLCJkZWZhdWx0U2l6ZSIsImZvcndhcmRlZFJlZiIsImlkIiwiaWRGcm9tUHJvcHMiLCJtYXhTaXplIiwibWluU2l6ZSIsIm9uQ29sbGFwc2UiLCJvbkV4cGFuZCIsIm9uUmVzaXplIiwib3JkZXIiLCJzdHlsZSIsInN0eWxlRnJvbVByb3BzIiwidGFnTmFtZSIsIlR5cGUiLCJyZXN0IiwiY29udGV4dCIsIkVycm9yIiwiY29sbGFwc2VQYW5lbCIsImV4cGFuZFBhbmVsIiwiZ2V0UGFuZWxTaXplIiwiZ2V0UGFuZWxTdHlsZSIsImdyb3VwSWQiLCJpc1BhbmVsQ29sbGFwc2VkIiwicmVnaXN0ZXJQYW5lbCIsInJlc2l6ZVBhbmVsIiwidW5yZWdpc3RlclBhbmVsIiwicGFuZWxJZCIsInBhbmVsRGF0YVJlZiIsImNhbGxiYWNrcyIsImNvbnN0cmFpbnRzIiwiaWRJc0Zyb21Qcm9wcyIsInVuZGVmaW5lZCIsImRldldhcm5pbmdzUmVmIiwiZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwiY29sbGFwc2UiLCJleHBhbmQiLCJnZXRJZCIsImdldFNpemUiLCJpc0NvbGxhcHNlZCIsImlzRXhwYW5kZWQiLCJyZXNpemUiLCJzaXplIiwicGFyc2VGbG9hdCIsImZsZXhHcm93IiwidG9GaXhlZCIsIlBhbmVsIiwicHJvcHMiLCJyZWYiLCJhc3NlcnQiLCJleHBlY3RlZENvbmRpdGlvbiIsIm1lc3NhZ2UiLCJlcnJvciIsIlBSRUNJU0lPTiIsImZ1enp5Q29tcGFyZU51bWJlcnMiLCJhY3R1YWwiLCJleHBlY3RlZCIsImZyYWN0aW9uRGlnaXRzIiwiZGVsdGEiLCJmdXp6eU51bWJlcnNFcXVhbCIsInBhbmVsQ29uc3RyYWludHMiLCJwYW5lbENvbnN0cmFpbnRzQXJyYXkiLCJwYW5lbEluZGV4IiwiaGFsZndheVBvaW50IiwiTWF0aCIsIm1pbiIsImFkanVzdExheW91dEJ5RGVsdGEiLCJsYXlvdXQiLCJwcmV2TGF5b3V0IiwicGl2b3RJbmRpY2VzIiwidHJpZ2dlciIsIm5leHRMYXlvdXQiLCJmaXJzdFBpdm90SW5kZXgiLCJzZWNvbmRQaXZvdEluZGV4IiwiZGVsdGFBcHBsaWVkIiwiaW5kZXgiLCJwcmV2U2l6ZSIsImxvY2FsRGVsdGEiLCJhYnMiLCJpbmNyZW1lbnQiLCJtYXhBdmFpbGFibGVEZWx0YSIsIm1heFNhZmVTaXplIiwibGVuZ3RoIiwibWluQWJzRGVsdGEiLCJwaXZvdEluZGV4IiwiZGVsdGFSZW1haW5pbmciLCJ1bnNhZmVTaXplIiwic2FmZVNpemUiLCJ0b1ByZWNpc2lvbiIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwidG90YWxTaXplIiwicmVkdWNlIiwidG90YWwiLCJnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwIiwiQXJyYXkiLCJmcm9tIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4IiwiaGFuZGxlcyIsImZpbmRJbmRleCIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsImRldGVybWluZVBpdm90SW5kaWNlcyIsImRyYWdIYW5kbGVJZCIsImdldFBhbmVsR3JvdXBFbGVtZW50IiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRSZXNpemVIYW5kbGVFbGVtZW50IiwiZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMiLCJoYW5kbGVJZCIsInBhbmVsc0FycmF5IiwiX3BhbmVsc0FycmF5JGluZGV4JGlkIiwiX3BhbmVsc0FycmF5JGluZGV4IiwiX3BhbmVsc0FycmF5JGlkIiwiX3BhbmVsc0FycmF5IiwiaW5kZXhPZiIsImlkQmVmb3JlIiwiaWRBZnRlciIsInVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yIiwiY29tbWl0dGVkVmFsdWVzUmVmIiwiZWFnZXJWYWx1ZXNSZWYiLCJwYW5lbERhdGFBcnJheSIsInNldExheW91dCIsImRpZFdhcm5BYm91dE1pc3NpbmdSZXNpemVIYW5kbGUiLCJlYWdlclZhbHVlcyIsImdyb3VwRWxlbWVudCIsImNsZWFudXBGdW5jdGlvbnMiLCJtYXAiLCJvbktleURvd24iLCJldmVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsInBhbmVsRGF0YSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9yRWFjaCIsImNsZWFudXBGdW5jdGlvbiIsImFyZUVxdWFsIiwiYXJyYXlBIiwiYXJyYXlCIiwiaXNLZXlEb3duIiwidHlwZSIsImlzTW91c2VFdmVudCIsInN0YXJ0c1dpdGgiLCJpc1RvdWNoRXZlbnQiLCJnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uIiwiZGlyZWN0aW9uIiwiaXNIb3Jpem9udGFsIiwiY2xpZW50WCIsImNsaWVudFkiLCJmaXJzdFRvdWNoIiwidG91Y2hlcyIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2FsY3VsYXRlRHJhZ09mZnNldFBlcmNlbnRhZ2UiLCJpbml0aWFsRHJhZ1N0YXRlIiwiaGFuZGxlRWxlbWVudCIsImluaXRpYWxDdXJzb3JQb3NpdGlvbiIsImN1cnNvclBvc2l0aW9uIiwiZ3JvdXBSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ3JvdXBTaXplSW5QaXhlbHMiLCJ3aWR0aCIsImhlaWdodCIsIm9mZnNldFBpeGVscyIsIm9mZnNldFBlcmNlbnRhZ2UiLCJjYWxjdWxhdGVEZWx0YVBlcmNlbnRhZ2UiLCJrZXlib2FyZFJlc2l6ZUJ5Iiwic2hpZnRLZXkiLCJtb3ZlbWVudCIsImNhbGxQYW5lbENhbGxiYWNrcyIsInBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAiLCJsYXN0Tm90aWZpZWRTaXplIiwiY29tcGFyZUxheW91dHMiLCJhIiwiYiIsImNvbXB1dGVQYW5lbEZsZXhCb3hTdHlsZSIsImRyYWdTdGF0ZSIsInByZWNpc2lvbiIsImZsZXhCYXNpcyIsImZsZXhTaHJpbmsiLCJvdmVyZmxvdyIsInBvaW50ZXJFdmVudHMiLCJjdXJyZW50U3RhdGUiLCJnZXRDdXJzb3JTdHlsZSIsInN0YXRlIiwicmVzZXRHbG9iYWxDdXJzb3JTdHlsZSIsImhlYWQiLCJyZW1vdmVDaGlsZCIsInNldEdsb2JhbEN1cnNvclN0eWxlIiwiYXBwZW5kQ2hpbGQiLCJpbm5lckhUTUwiLCJkZWJvdW5jZSIsImNhbGxiYWNrIiwiZHVyYXRpb25NcyIsInRpbWVvdXRJZCIsImNhbGxhYmxlIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UiLCJzdG9yYWdlT2JqZWN0IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm5hbWUiLCJzZXRJdGVtIiwidmFsdWUiLCJnZXRQYW5lbEdyb3VwS2V5IiwiYXV0b1NhdmVJZCIsImdldFBhbmVsS2V5IiwicGFuZWxzIiwicGFuZWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic29ydCIsImpvaW4iLCJsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZSIsInN0b3JhZ2UiLCJwYW5lbEdyb3VwS2V5Iiwic2VyaWFsaXplZCIsInBhcnNlZCIsInBhcnNlIiwic2F2ZVBhbmVsR3JvdXBTdGF0ZSIsInBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSIsInNpemVzIiwiX2xvYWRTZXJpYWxpemVkUGFuZWxHMiIsInBhbmVsS2V5IiwiZXhwYW5kVG9TaXplcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyIsIndhcm5pbmdzIiwicHVzaCIsInZhbGlkYXRlUGFuZWxHcm91cExheW91dCIsIm5leHRMYXlvdXRUb3RhbFNpemUiLCJhY2N1bXVsYXRlZCIsInJlbWFpbmluZ1NpemUiLCJMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMIiwiZGVmYXVsdFN0b3JhZ2UiLCJkZWJvdW5jZU1hcCIsIlBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmIiwib25MYXlvdXQiLCJzZXREcmFnU3RhdGUiLCJwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmIiwicGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYiLCJNYXAiLCJwcmV2RGVsdGFSZWYiLCJwYW5lbERhdGFBcnJheUNoYW5nZWQiLCJkaWRMb2dJZEFuZE9yZGVyV2FybmluZyIsImRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nIiwicHJldlBhbmVsSWRzIiwiZ2V0TGF5b3V0IiwidW5zYWZlTGF5b3V0Iiwic2FmZUxheW91dCIsImRlYm91bmNlZFNhdmUiLCJjbG9uZWRQYW5lbERhdGFBcnJheSIsImNsb25lZFBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSIsInBhbmVsSWRzIiwicGFuZWxzSGF2ZUNoYW5nZWQiLCJmaW5kIiwiaXNWYWxpZCIsInBhbmVsU2l6ZSIsInBhbmVsRGF0YUhlbHBlciIsInNldCIsImlzTGFzdFBhbmVsIiwiZmluZFBhbmVsRGF0YUluZGV4IiwicHJldlBhbmVsU2l6ZSIsImdldCIsImJhc2VTaXplIiwiaXNQYW5lbEV4cGFuZGVkIiwicGFuZWxBIiwicGFuZWxCIiwib3JkZXJBIiwib3JkZXJCIiwicmVnaXN0ZXJSZXNpemVIYW5kbGUiLCJyZXNpemVIYW5kbGVyIiwiaW5pdGlhbExheW91dCIsImRpciIsImxheW91dENoYW5nZWQiLCJ1bnNhZmVQYW5lbFNpemUiLCJzdGFydERyYWdnaW5nIiwiZHJhZ0hhbmRsZVJlY3QiLCJzdG9wRHJhZ2dpbmciLCJzcGxpY2UiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsIlByb3ZpZGVyIiwiUGFuZWxHcm91cCIsInByZXZQYW5lbERhdGEiLCJ1c2VXaW5kb3dTcGxpdHRlclJlc2l6ZUhhbmRsZXJCZWhhdmlvciIsImRpc2FibGVkIiwibmV4dEluZGV4IiwibmV4dEhhbmRsZSIsImZvY3VzIiwiUGFuZWxSZXNpemVIYW5kbGUiLCJvbkRyYWdnaW5nIiwidGFiSW5kZXgiLCJkaXZFbGVtZW50UmVmIiwiY2FsbGJhY2tzUmVmIiwicGFuZWxHcm91cENvbnRleHQiLCJyZXNpemVIYW5kbGVJZCIsImlzRHJhZ2dpbmciLCJpc0ZvY3VzZWQiLCJzZXRJc0ZvY3VzZWQiLCJzZXRSZXNpemVIYW5kbGVyIiwic3RvcERyYWdnaW5nQW5kQmx1ciIsImRpdkVsZW1lbnQiLCJibHVyIiwib25Nb3ZlIiwib25Nb3VzZUxlYXZlIiwidGFyZ2V0RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiYm9keSIsIndpbmRvdyIsImN1cnNvciIsInRvdWNoQWN0aW9uIiwidXNlclNlbGVjdCIsIm9uQmx1ciIsIm9uRm9jdXMiLCJvbk1vdXNlRG93biIsIm5hdGl2ZUV2ZW50Iiwib25Nb3VzZVVwIiwib25Ub3VjaENhbmNlbCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoU3RhcnQiLCJyb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;